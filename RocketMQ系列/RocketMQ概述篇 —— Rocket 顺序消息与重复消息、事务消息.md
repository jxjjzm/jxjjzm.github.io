### RocketMQ概述篇 —— Rocket 顺序消息与重复消息、事务消息 ###
***

### 一、顺序消息 ###

#### （一）、概述 ####

消息有序指的是一类消息消费时，能按照发送的顺序来消费。例如：一个订单产生了 3 条消息，分别是订单创建、订单付款、订单完成。消费时，要按照这个顺序消费才有意义。但同时订单之间又是可以并行消费的。

分析：假如生产者产生了2条消息：M1、M2，要保证这两条消息的顺序，应该怎样做？你可能会采用这种方式保证消息顺序：M1发送到S1后，M2发送到S2，如果要保证M1先于M2被消费，那么需要M1到达消费端后，通知S2，然后S2再将M2发送到消费端。

![](http://upload-images.jianshu.io/upload_images/1760830-0caf13bf4f73a0c7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

这个模型存在的问题是，如果M1和M2分别发送到两台Server上，就不能保证M1先达到，也就不能保证M1被先消费，那么就需要在MQ Server集群维护消息的顺序。那么如何解决？一种简单的方式就是将M1、M2发送到同一个Server上：这样可以保证M1先于M2到达MQServer（客户端等待M1成功后再发送M2），根据先达到先被消费的原则，M1会先于M2被消费，这样就保证了消息的顺序。

![](http://upload-images.jianshu.io/upload_images/1760830-652bc4e9a3fce157?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

这个模型，理论上可以保证消息的顺序，但在实际运用中你应该会遇到下面的问题：



- 1）网络延迟问题：只要将消息从一台服务器发往另一台服务器，就会存在网络延迟问题。如上图所示，如果发送M1耗时大于发送M2的耗时，那么M2就先被消费，仍然不能保证消息的顺序。
- 2）消费端负载情况：即使M1和M2同时到达消费端，由于不清楚消费端1和消费端2的负载情况，仍然有可能出现M2先于M1被消费。



![](http://upload-images.jianshu.io/upload_images/1760830-36da3bb2eec70a4f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


如何解决这两个问题？将M1和M2发往同一个消费者即可，且发送M1后，需要消费端响应成功后才能发送M2。但又引入另外一个问题：如果发送M1后，消费端1没有响应，那是继续发送M2呢，还是重新发送M1？一般为了保证消息一定被消费，肯定会选择重发M1到另外一个消费端2

![](http://upload-images.jianshu.io/upload_images/1760830-1c4a3bf771f7a644?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

这样的模型就严格保证消息的顺序，细心的你仍然会发现问题，消费端1没有响应Server时有两种情况，一种是M1确实没有到达，另外一种情况是消费端1已经响应，但是Server端没有收到。如果是第二种情况，重发M1，就会造成M1被重复消费。也就是我们后面要说的第二个问题，消息重复问题。


回过头来看消息顺序问题，严格的顺序消息非常容易理解，而且处理问题也比较容易，要实现严格的顺序消息，简单且可行的办法就是：

	保证生产者 - MQServer - 消费者是一对一对一的关系

虽然这种设计能够保证严格的消息顺序，但是这样设计，并行度就成为了消息系统的瓶颈（吞吐量不够），也会导致更多的异常处理，比如：只要消费端出现问题，就会导致整个处理流程阻塞，我们不得不花费更多的精力来解决阻塞的问题。但我们的最终目标是要集群的高容错性和高吞吐量。这似乎是一对不可调和的矛盾，那么阿里是如何解决的？

其实，有些问题，看起来很重要，但实际上我们可以通过合理的设计或者将问题分解来规避。如果硬要把时间花在解决它们身上，实际上是浪费的，效率低下的。从这个角度来看消息的顺序问题，我们可以得出两个结论：

- 不关注乱序的应用实际大量存在
- 队列无序并不意味着消息无序

**总结：**

RocketMQ可以严格的保证消息有序，但其也存在固有的缺陷：

- 发送顺序消息无法利用集群FailOver特性
- 消费顺序消息的并行度依赖于队列数量
- 队列热点问题，个别队列由于哈希不均导致消息过多，消费速度跟不上，产生消息堆积问题
- 遇到消息失败的消息，无法跳过，当前队列消费暂停


#### （二）、实现原理 ####

![](https://i.imgur.com/qOwXzi5.png)

下面我们从代码角度分析RocketMQ怎么实现发送顺序消息：一般消息是通过轮询所有队列来发送的（负载均衡策略），顺序消息可以根据业务，比如说订单号相同的消息发送到同一个队列。

**生产者端部分代码示例：**

![](http://upload-images.jianshu.io/upload_images/4943997-295659a6477316a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

（注意，MessageQueueSelector将用于指定特定的消息发往特定的队列当中）

**消费者端部分代码示例：**

![](http://upload-images.jianshu.io/upload_images/4943997-124bb9b1e8260b9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

（注意：在以前普通消费消息时设置的回调是MessageListenerConcurrently，而顺序消费的回调设置是MessageListenerOrderly。其作用是必须等前面的消息消费完，后面的消息才能进行消费。）

**执行结果：**

当我们启动2个Consumer进行消费时，可以观察得到，虽然从全局上来看，消息的消费不是有序的，但是每一个订单下的3条消息是顺序消费的！

![](http://upload-images.jianshu.io/upload_images/4943997-882ccf7fd8a20baf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


其实，如果需要保证消息的顺序消费，那么很简单，首先需要做到一组需要有序消费的消息发往同一个broker的同一个队列上！其次消费者端采用有序Listener即可。

这里，RocketMQ底层是如何做到消息顺序消费的，看一看源码你就能大概了解到，至少来说，在多线程消费场景下，一个线程只去消费一个队列上的消息，那么自然就保证了消息消费的顺序性，同时也保证了多个线程之间的并发性。也就是说其实broker并不能完全保证消息的顺序消费，它仅仅能保证的消息的顺序发送而已！



### 二、重复消息 ###

上面在解决消息顺序问题时，引入了一个新的问题，就是消息重复。那么RocketMQ是怎样解决消息重复的问题呢？还是“恰好”不解决。

造成消息的重复的根本原因是：网络不可达。只要通过网络交换数据，就无法避免这个问题。所以解决这个问题的办法就是不解决，转而绕过这个问题。那么问题就变成了：如果消费端收到两条一样的消息，应该怎样处理？

- 消费端处理消息的业务逻辑保持幂等性（ 即服务端去重 —— 在编程中，一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。）
- 保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现。

（第1条很好理解，只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样。第2条原理就是利用一张日志表来记录已经处理成功的消息的ID，如果新到的消息ID已经在日志表中，那么就不再处理这条消息。
）

**RocketMQ不保证消息不重复，如果你的业务需要保证严格的不重复消息，需要你自己在业务端去重。** （正常情况下出现重复消息的概率不一定大，且由消息系统实现的话，肯定会对消息系统的吞吐量和高可用有影响，所以最好还是由业务端自己处理消息重复的问题，这也是RocketMQ不解决消息重复的问题的原因。）

RocketMQ无法避免消息重复，所以如果业务对消费重复非常敏感，务必要在业务层面去重，有以下几种去重方式：

- 将消息的唯一键，可以是msgId,也可以是消息内容中的唯一标识字段，例如订单Id等，消费之前判断是否在Db或Tair（全局KV存储）中存在，如果不存在则插入并消费，否则跳过。（实际过程要考虑原子性问题，判断是否存在可以尝试插入，如果报主键冲突，则插入失败，直接跳过）
- 使用业务层面的状态机去重


































