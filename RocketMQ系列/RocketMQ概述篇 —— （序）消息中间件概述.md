### RocketMQ概述篇 —— （序）消息中间件概述 ###
***

### 一、概述 ###

#### 1.中间件 ####

中间件(middleware)是基础软件的一大类，属于可复用的软件范畴。中间件在操作系统软件，网络和数据库之上，应用软件之下，总的作用是为处于自己上层的应用软件提供运行于开发的环境，帮助用户灵活、高效的开发和集成复杂的应用软件。IDC对中间件的定义为：中间件是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源，中间件定位于客户机服务器的操作系统之上，管理计算机资源和网络通信。


按照IDC的分类方法，中间件可分为六类：

- 终端仿真/屏幕转换
- 数据访问中间件（UDA）
- 远程过程调用中间件（RPC）
- 消息中间件（MOM）
- 交易中间件（TPM）
- 对象中间件

一般来讲，中间件具有以下一些特点：满足大量应用的需求，运行于多种硬件和操作系统平台，支持分布式计算， 支持标准接口和协议。开发人员通过调用中间件提供的大量API，实现异构环境的通信，从而屏蔽异构系统中复杂的操作系统和网络协议。 由于标准接口对于可移植性和标准协议对于互操作性的重要性，中间件已成为许多标准化工作的主要部分。分布式应用软件借助中间件可以在不同的技术之间共享资源。总的来说，中间件屏蔽了底层操作系统的复杂性，使程序开发人员面对一个简单而统一的开发环境，减少了程序设计的复杂性，注意力集中与自己的业务上，不必再为程序在不同软件系统上的移植而重复工作，从而大大减少了技术上的负担。 
     

#### 2.消息中间件 ####

 面向消息的中间件（MOM），提供了以松散耦合的灵活方式集成应用程序的一种机制。它们提供了基于存储和转发的应用程序之间的异步数据发送，即应用程序彼此不直接通信，而是与作为中介的MOM通信。MOM提供了有保证的消息发送（至少是在尽可能地做到这一点），应用程序开发人员无需了解远程过程调用（PRC）和网络/通信协议的细节。 
         
消息中间件利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息排队模型，它可以在分布式环境下扩展进程间的通信。 消息中间件适用于需要可靠的数据传送的分布式环境。采用消息中间件机制的系统中，不同的对象之间通过传递消息来激活对方的事件，完成相应的操作。发送者将消息发送给消息服务器，消息服务器将消息存放在若干队列中，在合适的时候再将消息转发给接收者。消息中间件能在不同平台之间通信，它常被用来屏蔽掉各种平台及协议之间的特性，实现应用程序之间的协同，其优点在于能够在客户和服务器之间提供同步和异步的连接，并且在任何时刻都可以将消息进行传送或者存储转发，这也是它比远程过程调用更进一步的原因。 

消息中间件一般有两种传递模型：点对点模型和发布-订阅模型。

**I、点对点模型（PTP）**

 点对点模型用于消息生产者和消息消费者之间点到点的通信。消息生产者将消息发动到由某个名字标识的特定消费者。这个名字实际上对应于消息服务中的一个队列（Queue），在消息传动给消费者之前它被存储在这个队列中。队列可以是持久的，以保证在消息服务出现故障时仍然能够传递消息。


![](https://i.imgur.com/kOVv1J8.png)

**II、发布-订阅模型（Pub/Sub）**

发布-订阅模型用称为主题（topic）的内容分层结构代替了PTP模型中的惟一目的地，发送应用程序发布自己的消息，指出消息描述的是有关分层结构中的一个主题的信息。希望接收这些消息的应用程序订阅了这个主题。订阅包含子主题的分层结构中的主题的订阅者可以接收该主题和其子主题发表的所有消息。

![](https://i.imgur.com/aq6BKa8.png)

### 二、消息中间件需要解决哪些问题？ ###

#### 1.Publish/Subscribe ####

发布订阅是消息中间件的最基本功能，也是相对于传统RPC通信而言。在此不再详述。

#### 2.Message Priority ####

规范中描述的优先级是指在一个消息队列中，每条消息都有不同的优先级，一般用整数来描述，优先级高的消息先投递，如果消息完全在一个内存队列中，那么在投递前可以按照优先级排序，令优先级高的先投递。由于RocketMQ所有消息都是持久化的，所以如果按照优先级来排序，开销会非常大，因此RocketMQ没有特意支持消息优先级，但是可以通过变通的方式实现类似功能，即单独配置一个优先级高的队列，和一个普通优先级的队列， 将不同优先级发送到不同队列即可。

对于优先级问题，可以归纳为2类：



- 只要达到优先级目的即可，不是严格意义上的优先级，通常将优先级划分为高、中、低，或者再多几个级别。每个优先级可以用不同的topic表示，发消息时，指定不同的topic来表示优先级，这种方式可以解决绝大部分的优先级问题，但是对业务的优先级精确性做了妥协。


- 严格的优先级，优先级用整数表示，例如0 ~ 65535，这种优先级问题一般使用不同topic解决就非常不合适。如果要让MQ解决此问题，会对MQ的性能造成非常大的影响。这里要确保一点，业务上是否确实需要这种严格的优先级，如果将优先级压缩成几个，对业务的影响有多大？


#### 3.Message Order ####

消息有序指的是一类消息消费时，能按照发送的顺序来消费。例如：一个订单产生了3条消息，分别是订单创建，订单付款，订单完成。消费时，要按照这个顺序消费才能有意义。但是同时订单之间是可以并行消费的。RocketMQ可以严格的保证消息有序。


#### 4.Message Filter ####

**I、Broker端消息过滤**

在Broker中，按照Consumer的要求做过滤，优点是减少了对于Consumer无用消息的网络传输。缺点是增加了Broker的负担，实现相对复杂。

1. 淘宝Notify支持多种过滤方式，包含直接按照消息类型过滤，灵活的语法表达式过滤，几乎可以满足最苛刻的过滤需求。
2. 淘宝RocketMQ支持按照简单的Message Tag过滤，也支持按照Message Header、body进行过滤。
3. CORBA Notification规范中也支持灵活的语法表达式过滤。


**II、Consumer端消息过滤**

这种过滤方式可由应用完全自定义实现，但是缺点是很多无用的消息要传输到Consumer端。


#### 5.Message Persistence ####

消息中间件通常采用的几种持久化方式：



- （1）持久化到数据库，例如Mysql。
- （2）持久化到KV存储，例如levelDB、伯克利DB等KV存储系统。
- （3）文件记录形式持久化，例如Kafka，RocketMQ
- （4）对内存数据做一个持久化镜像，例如beanstalkd，VisiNotify

(1)、(2)、(3)三种持久化方式都具有将内存队列Buffer进行扩展的能力，(4)只是一个内存的镜像，作用是当Broker挂掉重启后仍然能将之前内存的数据恢复出来。

JMS与CORBA Notification规范没有明确说明如何持久化，但是持久化部分的性能直接决定了整个消息中间件的性能。RocketMQ参考了Kafka的持久化方式，充分利用Linux文件系统内存cache来提高性能。


#### 6.Message Reliablity ####

影响消息可靠性的几种情况：



- （1）Broker正常关闭
- （2）Broker异常Crash
- （3）OS Crash
- （4）机器掉电，但是能立即恢复供电情况。
- （5）机器无法开机（可能是cpu、主板、内存等关键设备损坏）
- （6）磁盘设备损坏。

(1)、(2)、(3)、(4)四种情况都属于硬件资源可立即恢复情况，RocketMQ在这四种情况下能保证消息不丢，或者丢失少量数据（依赖刷盘方式是同步还是异步）。

(5)、(6)属于单点故障，且无法恢复，一旦发生，在此单点上的消息全部丢失。RocketMQ在这两种情况下，通过异步复制，可保证99%的消息不丢，但是仍然会有极少量的消息可能丢失。通过同步双写技术可以完全避免单点，同步双写势必会影响性能，适合对消息可靠性要求极高的场合，例如与Money相关的应用。RocketMQ从3.0版本开始支持同步双写。



#### 7.Low Latency Messaging ####

在消息不堆积情况下，消息到达Broker后，能立刻到达Consumer。RocketMQ使用长轮询Pull方式，可保证消息非常实时，消息实时性不低于Push。


#### 8.At least Once ####

是指每个消息必须投递一次。RocketMQ Consumer先pull消息到本地，消费完成后，才向服务器返回ack，如果没有消费一定不会ack消息，所以RocketMQ可以很好的支持此特性。


#### 9.Exactly Only Once ####



- 发送消息阶段，不允许发送重复的消息。
- 消费消息阶段，不允许消费重复的消息。

只有以上两个条件都满足情况下，才能认为消息是“Exactly Only Once”，而要实现以上两点，在分布式系统环境下，不可避免要产生巨大的开销。所以RocketMQ为了追求高性能，并不保证此特性，要求在业务上进行去重，也就是说消费消息要做到幂等性。RocketMQ虽然不能严格保证不重复，但是正常情况下很少会出现重复发送、消费情况，只有网络异常，Consumer启停等异常情况下会出现消息重复。（此问题的本质原因是网络调用存在不确定性，即既不成功也不失败的第三种状态，所以才产生了消息重复性问题）


#### 10.Broker的Buffer满了怎么办？ ####

Broker的Buffer通常指的是Broker中一个队列的内存Buffer大小，这类Buffer通常大小有限，如果Buffer满了以后怎么办？

下面是CORBA Notification规范中处理方式：

（1）RejectNewEvents 拒绝新来的消息，向Producer返回RejectNewEvents错误码。

（2）按照特定策略丢弃已有消息


- a) AnyOrder - Any event may be discarded on overflow. This is the default setting for this property.
- b) FifoOrder - The first event received will be the first discarded.
- c) LifoOrder - The last event received will be the first discarded.
- d) PriorityOrder - Events should be discarded in priority order, such that lower priority events will be discarded before higher priority events.
- e) DeadlineOrder - Events should be discarded in the order of shortest expiry deadline first.

RocketMQ没有内存Buffer概念，RocketMQ的队列都是持久化磁盘，数据定期清除。对于此问题的解决思路，RocketMQ同其他MQ有非常显著的区别，RocketMQ的内存Buffer抽象成一个无限长度的队列，不管有多少数据进来都能装得下，这个无限是有前提的，Broker会定期删除过期的数据，例如Broker只保存3天的消息，那么这个Buffer虽然长度无限，但是3天前的数据会被从队尾删除。


#### 11.回溯消费 ####

回溯消费是指Consumer已经消费成功的消息，由于业务上需求需要重新消费，要支持此功能，Broker在向Consumer投递成功消息后，消息仍然需要保留。并且重新消费一般是按照时间维度，例如由于Consumer系统故障，恢复后需要重新消费1小时前的数据，那么Broker要提供一种机制，可以按照时间维度来回退消费进度。RocketMQ支持按照时间回溯消费，时间维度精确到毫秒，可以向前回溯，也可以向后回溯。


#### 12.消息堆积 ####

消息中间件的主要功能是异步解耦，还有个重要功能是挡住前端的数据洪峰，保证后端系统的稳定性，这就要求消息中间件具有一定的消息堆积能力，消息堆积分以下两种情况：



- 消息堆积在内存Buffer，一旦超过内存Buffer，可以根据一定的丢弃策略来丢弃消息，如CORBA Notification规范中描述。适合能容忍丢弃消息的业务，这种情况消息的堆积能力主要在于内存Buffer大小，而且消息堆积后，性能下降不会太大，因为内存中数据多少对于对外提供的访问能力影响有限。


- 消息堆积到持久化存储系统中，例如DB，KV存储，文件记录形式。 当消息不能在内存Cache命中时，要不可避免的访问磁盘，会产生大量读IO，读IO的吞吐量直接决定了消息堆积后的访问能力。

评估消息堆积能力主要有以下四点：



- 消息能堆积多少条，多少字节？即消息的堆积容量。
- 消息堆积后，发消息的吞吐量大小，是否会受堆积影响？
- 消息堆积后，正常消费的Consumer是否会受影响？
- 消息堆积后，访问堆积在磁盘的消息时，吞吐量有多大？


#### 13.分布式事务 ####

已知的几个分布式事务规范，如XA，JTA等。其中XA规范被各大数据库厂商广泛支持，如Oracle，Mysql等。其中XA的TM实现佼佼者如Oracle Tuxedo，在金融、电信等领域被广泛应用。

分布式事务涉及到两阶段提交问题，在数据存储方面必然需要KV存储的支持，因为第二阶段的提交回滚需要修改消息状态，一定涉及到根据Key去查找Message的动作。RocketMQ在第二阶段绕过了根据Key去查找Message的问题，采用第一阶段发送Prepared消息时，拿到了消息的Offset，第二阶段通过Offset去访问消息，并修改状态，Offset就是数据的地址。

RocketMQ这种实现事务方式，没有通过KV存储做，而是通过Offset方式，存在一个显著缺陷，即通过Offset更改数据，会令系统的脏页过多，需要特别关注。

#### 14.定时消息 ####

定时消息是指消息发到Broker后，不能立刻被Consumer消费，要到特定的时间点或者等待特定的时间后才能被消费。

如果要支持任意的时间精度，在Broker层面，必须要做消息排序，如果再涉及到持久化，那么消息排序要不可避免的产生巨大性能开销。RocketMQ支持定时消息，但是不支持任意时间精度，支持特定的level，例如定时5s，10s，1m等。


#### 15.消息重试 ####

Consumer消费消息失败后，要提供一种重试机制，令消息再消费一次。Consumer消费消息失败通常可以认为有以下几种情况：



- 由于消息本身的原因，例如反序列化失败，消息数据本身无法处理（例如话费充值，当前消息的手机号被注销，无法充值）等。这种错误通常需要跳过这条消息，再消费其他消息，而这条失败的消息即使立刻重试消费，99%也不成功，所以最好提供一种定时重试机制，即过10s秒后再重试。


- 由于依赖的下游应用服务不可用，例如db连接不可用，外系统网络不可达等。遇到这种错误，即使跳过当前失败的消息，消费其他消息同样也会报错。这种情况建议应用sleep 30s，再消费下一条消息，这样可以减轻Broker重试消息的压力。


### 三、MQ技术选型 ###

![](https://i.imgur.com/tX4vRBB.png)

#### 1.ZeroMQ、ActiveMQ、RabbitMQ 比较 ####

- TPS： ZeroMQ最好，RabbitMQ次之，ActiveMQ最差。
- 持久化消息：zeroMQ不支持，ActiveMQ和RabbitMQ都支持。
- 综合技术实现（可靠性、灵活的路由、集群、事务、高可用的队列、消息排序、问题追踪、可视化管理工具、插件系统、社区）：RabbitMQ最好，ActiveMQ 次之，ZeroMQ 最差。
- 高并发：RabbitMQ最好。

综上所述，在RabbitMQ、activeM、zeroMQ三者中，RabbitMQ是首选。

#### 2.RabbitMQ、RocketMQ、Kafka比较 ####

![](https://i.imgur.com/P1iIsno.png)


- Kafka是LinkedIn开源的分布式发布-订阅消息系统，目前归属于Apache定级项目。Kafka主要特点是基于Pull的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输。0.8版本开始支持复制，不支持事务，对消息的重复、丢失、错误没有严格要求，适合产生大量数据的互联网服务的数据收集业务。



- RabbitMQ是使用Erlang语言开发的开源消息队列系统，基于AMQP协议来实现。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。AMQP协议更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。



- RocketMQ是阿里开源的消息中间件，它是纯Java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。RocketMQ思路起源于Kafka，但并不是Kafka的一个Copy，它对消息的可靠传输及事务性做了优化，目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、binglog分发等场景。


最后，我们从不同方面来综合比较下当前互联网行业最常用的两种MQ —— RabbitMQ、RocketMQ。

- 从消息持久化方面考虑，两者都支持持久化。
- 从消息顺序性方面考虑，RocketMQ支持，RabbitMQ不支持。
- 从消息处理量方面考虑，RocketMQ（大约100000/sec） >   RabbitMQ(大约20000/sec)。
- 从消息事务方面考虑，Alibaba的消息队列RocketMQ支持事务消息，Apache RocketMQ 不支持，RabbitMQ不支持。
- 从队列数目方面考虑，RocketMQ支持上万队列，RabbitMQ < 1000.
- 从定时消息方面考虑，RocketMQ支持，RabbitMQ不支持。
- 从横向扩展方面考虑，RocketMQ支持平滑扩展，RabbitMQ集群扩容依赖前端、LVS负载均衡调度。
- 从消息回溯方面考虑，RocketMQ支持消息回溯，RabbitMQ不支持。
- ...

(RocketMQ的商业版本是阿里的ONS)

### 四、MQ常见应用场景 ###

消息队列中间件是分布式系统中重要的组件，主要解决应用解耦，异步消息，流量削锋等问题，实现高性能，高可用，可伸缩和最终一致性架构。目前使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ等。

MQ 可以应用但不局限于以下业务场景：

- 一对多，多对多异步解耦，基于发布订阅模型，对分布式应用进行异步解耦，增加应用的水平扩展能力。
- 削峰填谷，大促等流量洪流突然来袭时，MQ 可以缓冲突发流量，避免下游订阅系统因突发流量崩溃。
- 日志监控，作为重要日志的监控通信管道，将应用日志监控对系统性能影响降到最低。
- 消息推送，为社交应用和物联网应用提供点对点推送，一对多广播式推送的能力。
- 金融报文，发送金融报文，实现金融准实时的报文传输，可靠安全。
- 电信信令，将电信信令封装成消息，传递到各个控制终端，实现准实时控制和信息传递。



### 1.应用解耦 ###

场景说明：用户下单后，订单系统需要通知库存系统。传统的做法是，订单系统调用库存系统的接口。如下图：

![](http://images2015.cnblogs.com/blog/270324/201607/270324-20160730143219809-1948583125.png)

传统模式的缺点：假如库存系统无法访问，则订单减库存将失败，从而导致订单失败，订单系统与库存系统耦合。如何解决以上问题呢？引入应用消息队列后的方案，如下图：

![](http://images2015.cnblogs.com/blog/270324/201607/270324-20160730143228325-953675504.png)


- 订单系统：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功
- 库存系统：订阅下单的消息，采用拉/推的方式，获取下单信息，库存系统根据下单信息，进行库存操作。

假如在下单时库存系统不能正常使用，也不影响正常下单，因为下单后，订单系统写入消息队列就不再关心其他的后续操作了。实现了订单系统与库存系统的应用解耦。


#### 2.流量消峰 ####

应用场景：流量削锋也是消息队列中的常用场景，一般在秒杀或团抢活动中使用广泛。秒杀活动中，一般会因为流量过大，导致流量暴增，应用挂掉。为解决这个问题，一般需要在应用前端加入消息队列。

- a、可以控制活动的人数
- b、可以缓解短时间内高流量压垮应用

![](http://images2015.cnblogs.com/blog/270324/201607/270324-20160730151710106-2043115158.png)

用户的请求，服务器接收后，首先写入消息队列。假如消息队列长度超过最大数量，则直接抛弃用户请求或跳转到错误页面。秒杀业务根据消息队列中的请求信息，再做后续处理


#### 3.异步处理 ####

场景说明：用户注册后，需要发注册邮件和注册短信。传统的做法有两种 1.串行的方式；2.并行方式。

- a、串行方式：将注册信息写入数据库成功后，发送注册邮件，再发送注册短信。以上三个任务全部完成后，返回给客户端。

![](http://images2015.cnblogs.com/blog/270324/201607/270324-20160730141220778-784471498.png)


- b、并行方式：将注册信息写入数据库成功后，发送注册邮件的同时，发送注册短信。以上三个任务完成后，返回给客户端。与串行的差别是，并行的方式可以提高处理的时间。

![](http://images2015.cnblogs.com/blog/270324/201607/270324-20160730141236169-1140938329.png)


#### 4.消息通讯 ####

消息通讯是指，消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。

**点对点通讯：**

![](http://images2015.cnblogs.com/blog/270324/201607/270324-20160730153544294-1894255488.png)

（客户端A和客户端B使用同一队列，进行消息通讯。）

**聊天室通讯：**

![](http://images2015.cnblogs.com/blog/270324/201607/270324-20160730153550184-1160563716.png)

（客户端A，客户端B，客户端N订阅同一主题，进行消息发布和接收。实现类似聊天室效果。）


#### 5.日志处理 ####

日志处理是指将消息队列用在日志处理中，比如Kafka的应用，解决大量日志传输的问题。架构简化如下

![](http://images2015.cnblogs.com/blog/270324/201607/270324-20160730152810934-1818295010.png)