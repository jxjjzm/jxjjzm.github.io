### 浅析synchronized & volatile & 锁优化 ###
***
### 一、synchronized ###

Synchronized的作用主要有三点：

- 互斥性：确保线程互斥的访问同步代码
- 可见性：保证共享变量的修改能够及时可见
- 重排序：有效解决重排序问题。（Synchronized同步中的代码JVM不会轻易优化重排序）

Synchronized的具体用法这里就不做讲解了，我们来分析下Synchronized的实现原理：

#### 1.synchronized修饰代码块 ####

	public class SynchronizedDemo {
	    public void method (){
	        synchronized (this) {
	            System.out.println("method 1 start!!!!");
	        }
	    }
	}

javac -encoding utf-8 SynchronizedDemo.java 编译生成class 后，javap -c 反编译一下，看指令：

![](http://images2015.cnblogs.com/blog/584866/201704/584866-20170405112214082-1974483511.png)

**同步代码块：**同步代码块是使用monitorenter和monitorexit指令实现的。对于synchronized同步块当Java源代码被javac编译成bytecode的时候，会在同步块的入口位置和退出位置分别插入monitorenter和monitorexit字节码指令。 JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个 monitor 与之关联，当且一个monitor 被持有后，它将处于锁定状态。线程执行到 monitorenter 指令时，将会尝试获取对象所对应的 monitor 的所有权，即尝试获得对象的锁。

（1）monitorenter监视器准入指令

每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：

- 如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。
- 如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.
- 如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。

（2）monitorexit监视器释放指令

- 执行monitorexit的线程必须是objectref所对应的monitor的所有者。
- 指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权

![](https://images2018.cnblogs.com/blog/1278254/201804/1278254-20180411011622550-897592260.png)

#### 2.synchronized修饰方法 ####


	package lock;
	
	public class SynchronizedDemo0 {
	    public synchronized void method (){
	        System.out.println("method start!!!!");
	    }
	}

javap -v 查看class文件，发现method上加了同步标签，本质上还是monitor

![](http://images2015.cnblogs.com/blog/584866/201704/584866-20170405183523503-2138017328.png)


synchronized方法则会被翻译成普通的方法调用和返回指令如:invokevirtual、areturn指令，在VM字节码层面并没有任何特别的指令来实现被synchronized修饰的方法，而是在Class文件的方法表中将该方法的access_flags字段中的synchronized标志位置1，表示该方法是同步方法并使用调用该方法的对象或该方法所属的Class在JVM的内部对象表示Klass做为锁对象。


**同步方法：**同步方法是使用修饰符ACC_SYNCHRONIZED实现的。synchronized方法会被翻译成普通的方法调用和返回指令如:invokevirtual、areturn指令，在VM字节码层面并没有任何特别的指令来实现被synchronized修饰的方法，而是在Class文件的方法表中将该方法的access_flags字段中的synchronized标志位置1，表示该方法是同步方法并使用调用该方法的对象或该方法所属的Class在JVM的内部对象表示class做为锁对象。

#### 总结 ####



- JVM规范规定JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步是使用monitorenter和monitorexit指令实现的，而方法同步是使用修饰符ACC_SYNCHRONIZED实现的。
- synchronized 获取锁是可重入的。



### 二、volatile ###

#### 1.volatile 特性 ####

Java 语言中的 Volatile 变量可以被看作是一种 “程度较轻的 synchronized”；与 synchronized 块相比，volatile 变量所需的编码较少，并且运行时开销也较少，但是它所能实现的功能也仅是 synchronized 的一部分。Volatile 变量具有 synchronized 的可见性特性，但是不具备原子特性。

![](https://i.imgur.com/5vs94EK.png)

一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：

- 可见性：保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
- 重排序：禁止进行指令重排序。
               
说明：a）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；b）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。

因此，您只能在有限的一些情形下使用 volatile 变量替代锁。要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件：
  

- 对变量的写操作不依赖于当前值。
- 该变量没有包含在具有其他变量的不变式中。

实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。


#### 2.volatile 实现原理分析  ####

![](https://i.imgur.com/0ncF9Wx.png)

**（1）可见性**

**可见性：**处理器为了提高处理速度，不直接和内存进行通讯，而是先将系统内存的数据读到内部缓存（L1,L2或其他）后再进行操作，但操作完之后不知道何时会写到内存，如果对声明了Volatile变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。

lock前缀指令在多核处理器下会引发了两件事情：

- 将当前处理器缓存行的数据会写回到系统内存。
- 这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效。

这两件事情在IA-32软件开发者架构手册的第三册的多处理器管理章节（第八章）中有详细阐述。



- **Lock前缀指令会引起处理器缓存回写到内存。**Lock前缀指令导致在执行指令期间，声言处理器的 LOCK# 信号。在多处理器环境中，LOCK# 信号确保在声言该信号期间，处理器可以独占使用任何共享内存。（因为它会锁住总线，导致其他CPU不能访问总线，不能访问总线就意味着不能访问系统内存），但是在最近的处理器里，LOCK＃信号一般不锁总线，而是锁缓存，毕竟锁总线开销比较大。在8.1.4章节有详细说明锁定操作对处理器缓存的影响，对于Intel486和Pentium处理器，在锁操作时，总是在总线上声言LOCK#信号。但在P6和最近的处理器中，如果访问的内存区域已经缓存在处理器内部，则不会声言LOCK#信号。相反地，它会锁定这块内存区域的缓存并回写到内存，并使用缓存一致性机制来确保修改的原子性，此操作被称为“缓存锁定”，缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据。



- **一个处理器的缓存回写到内存会导致其他处理器的缓存无效。**IA-32处理器和Intel 64处理器使用MESI（修改，独占，共享，无效）控制协议去维护内部缓存和其他处理器缓存的一致性。在多核处理器系统中进行操作的时候，IA-32 和Intel 64处理器能嗅探其他处理器访问系统内存和它们的内部缓存。它们使用嗅探技术保证它的内部缓存，系统内存和其他处理器的缓存的数据在总线上保持一致。例如在Pentium和P6 family处理器中，如果通过嗅探一个处理器来检测其他处理器打算写内存地址，而这个地址当前处理共享状态，那么正在嗅探的处理器将无效它的缓存行，在下次访问相同内存地址时，强制执行缓存行填充。

![](https://i.imgur.com/rBcnWpR.png)


**（2）禁止重排序**

为了实现volatile的内存语义，编译器在生成字节码时会在指令序列中插入内存屏障（观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令，lock前缀指令其实就相当于一个内存屏障。）来禁止特定类型的处理器重排序，在《浅析Java内存模型》一篇中已经对重排序和先行发生规则进行了阐述，其中就有针对volatile的规则，如果对此不熟悉可以先去阅读下《浅析Java内存模型》，此处不再重复赘述。



#### 3.volatile 使用场景  ####

下面引用了网上volatile几种典型使用场景供读者参考：

![](https://i.imgur.com/0FHNUiz.png)

![](https://i.imgur.com/YP2FCs3.png)

![](https://i.imgur.com/dIdXR2r.png)

![](https://i.imgur.com/Gnb95MD.png)

![](https://i.imgur.com/7dgG1WC.png)



### 三、锁的优化及注意事项 ###


### （一）锁优化 ###


#### 1.自旋锁与自适应自旋 ####

我们知道互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成（上下文切换），这些操作给系统的并发性能带来了很大的压力。同时，虚拟机的开发团队也注意到了在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段短暂时间去挂起和恢复线程并不值得。如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一会儿”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只须让线程执行一个忙循环（自旋），这项技术就是所谓的**自旋锁。**（自旋锁在JDK1.4.2就已经引入，只不过默认是关闭的，可以使用-XX:::+UseSpinning参数来开启，在JDK1.6中就已经改为默认开启了）


	public class SpinLock {
	
	  private AtomicReference<Thread> sign =new AtomicReference<>();
	
	  public void lock(){
	    Thread current = Thread.currentThread();
	    while(!sign .compareAndSet(null, current)){
	    }
	  }
	
	  public void unlock (){
	    Thread current = Thread.currentThread();
	    sign .compareAndSet(current, null);
	  }
	}


自旋锁使用了CAS原子操作，lock函数将owner设置为当前线程，并且预测原来的值为空。unlock函数将owner设置为null，并且预测值为当前线程。
当有第二个线程调用lock操作时由于owner值不为空，导致循环一直被执行，直至第一个线程调用unlock函数将owner设置为null，第二个线程才能进入临界区。


自旋等待不能代替阻塞，且先不说对处理器数量的要求，自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，所以如果锁被占用的时间很短，自旋等待的效果就会非常好，反之如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有用的工作，反而会带来性能的浪费。因此自旋等待的时间必须要有一定的限度，如果自旋超过了限定的次数仍然没有成功活得锁，就应当使用传统的方式去挂起线程了。自旋次数的默认值是10次，用户可以使用参数-XX：PreBlockSpin来更改。

在JDK1.6中引入了**自适应的自旋锁**。自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。另一方面，如果自旋很少成功获得过，那么以后要获得这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。


#### 2.锁消除 ####

锁消除是指虚拟机在及时编译器运行时,对一些代码上要求同步,但是被检测到不可能存在共享数据竞争的锁进行消除.锁消除的主要判断依据来源于逃逸分析的数据支持,如果判断在一段代码中,堆上的所有数据都不会被逃逸出去而被其他线程访问到,那就可以把他们当做栈上数据对待,认为他们是私有的,同步加锁就无须进行.也许读者会有疑问，变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是程序员自己应该是很清楚的，怎么会在明知道不存在数据争用的情况下要求同步呢？答案是有许多同步操作并不是程序员自己加入的，同步的代码在Java程序中的普遍程度也许超多了大部分读者的想象。

		  public String concatStrings(Strin s1,Strin s2,Strin s3) {
		    return s1+s2+s3;
		  }

这段非常简单的代码仅仅是输出三个字符串相加的结果，无论是源码字面上还是程序语义上都没有同步。我们也知道，由于String是一个不可变的类，对字符串的连接操作总是通过生成新的String对象来进行的，因此Javac编译器会对String连接做自动优化。在JDK1.5之前，会转化为StringBuffer对象的连续append操作，在JDK1.5及以后的版本中，会转化为StringBuilder对象的连续append操作。

	  public String concatStrings(Strin s1,Strin s2,Strin s3) {
			StringBuffer sb = new StringBuffer();
			sb.append(s1);
			sb.append(s2);
			sb.append(s3);			    
			return sb.toString();
		}

现在大家还认为这段代码没有涉及同步吗？每个StringBuffer.append()方法中都有一个同步块，锁就是sb对象。虚拟机观察变量sb,很快会发现它的动态作用域被限制在concatString()方法的内部。也就是sb的所有引用永远不会“逃逸”到concatString()方法之外，其他线程无法访问到它，所以这里虽然有锁，但是可以被安全地消除掉，在即时编译之后，这段代码就会忽略掉所有的同步而直接执行了。


#### 3.锁粗化 ####

原则上，我们在编写代码的时候，总是推荐将同步块尽可能的小。这样是为了使得需要同步的操作数量小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。大部分情况下，这个原则是正确的。但是如果如果一系列连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁的同步操作也会导致不必要的性能损耗。如果虚拟机探测到很多零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。即加大了同步块。





#### 4.偏向锁/轻量级锁/重量级锁 ####


JDK 1.6 为了减少获得锁和释放锁所带来的性能消耗，引入了"偏向锁"和"轻量级锁"，所以在JDK1.6里锁共有四种状态：无锁、偏向锁、轻量级锁和重量级锁（会随着竞争情况逐渐升级（锁可以升级但不能降级））。

![](http://images2015.cnblogs.com/blog/899685/201610/899685-20161025105953062-1932807640.png)

**Java对象头：**

要理解"偏向锁" 和 "轻量级锁"的原理和运作过程，必须从HotSpot虚拟机的对象头（synchronized用的锁就是存在Java对象头里的）的内存布局开始介绍。HotSpot虚拟机的对象头分为两部分信息：Mark Word（标记字段）、Klass Pointer（类型指针）。其中Klass Point是对象指向它的类的元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例；Mark Word用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等，它是实现轻量级锁和偏向锁的关键所在。


![](http://blog.zswlib.com/wp-content/uploads/2017/12/%E6%97%A0%E6%A0%87%E9%A2%98.png)



#### I、轻量级锁 ####

轻量级锁是相对于使用操作系统互斥量来实现的传统锁而言的，因此传统锁机制就被称为"重量级锁"。首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。

![](http://images2015.cnblogs.com/blog/899685/201610/899685-20161025111821296-1590704619.png)


**获取锁** 


- 1. 判断当前对象是否处于无锁状态（hashcode、0、01），若是，则JVM首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word），owner指针指向对象的Mark Word；否则执行步骤（3）； 


![](https://images2018.cnblogs.com/blog/1278254/201804/1278254-20180411012148294-467773713.png)


- 2. JVM利用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指正，如果成功表示竞争到锁，则将锁标志位变成00（表示此对象处于轻量级锁状态），执行同步操作；如果失败则执行步骤（3）； 

![](https://images2018.cnblogs.com/blog/1278254/201804/1278254-20180411012256758-224864684.png)

- 3. 判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，锁标志位变成10，后面等待的线程将会进入阻塞状态；

**释放锁** 

轻量级锁的释放也是通过CAS操作来进行的，主要步骤如下： 


- 1. 取出在获取轻量级锁保存在Displaced Mark Word中的数据； 
- 2. 用CAS操作将取出的数据替换当前对象的Mark Word中，如果成功，则说明释放锁成功，否则执行（3）； 
- 3. 如果CAS操作替换失败，说明有其他线程尝试获取该锁，则需要在释放锁的同时需要唤醒被挂起的线程。

对于轻量级锁，其性能提升的依据是“对于绝大部分的锁，在整个生命周期内都是不会存在竞争的”，如果打破这个依据则除了互斥的开销外，还有额外的CAS操作，因此在有多线程竞争的情况下，轻量级锁比重量级锁更慢；

#### II、偏向锁 ####

偏向锁也是JDK1.6中引入的一项锁优化，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了。（偏向锁，我的理解其实就是无锁竞争下可重入锁的简单实现。）

偏向锁的"偏"，就是偏心的"偏"、偏袒的"偏"。它的意思是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。

如果明白了前面轻量级锁中关于对象头Mark Word与线程之间的操作过程，那偏向锁的原理理解起来就会很简单。假设当前虚拟机启用了偏向锁（启用参数-XX:+UseBiasedLocking,JDK1.6后默认启用）,那么当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为“01”，即偏向模式。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作。当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束。根据锁对象目前是否处于被锁定的状态，撤销偏向后恢复到未锁定（标志位为“01”）或轻量级锁定（标志位为“00”）的状态，后续的同步操作就如上面介绍的轻量级锁那样执行。


![](http://images2015.cnblogs.com/blog/899685/201610/899685-20161025102843468-151954717.png)



**获取锁**


- 1. 检测Mark Word是否为可偏向状态，即是否为偏向锁1，锁标识位为01；
- 2. 若为可偏向状态，则测试线程ID是否为当前线程ID，如果是，则执行步骤（5），否则执行步骤（3）； 
- 3. 如果线程ID不为当前线程ID，则通过CAS操作竞争锁，竞争成功，则将Mark Word的线程ID替换为当前线程ID，否则执行线程（4）； 
- 4. 通过CAS竞争锁失败，证明当前存在多线程竞争情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块； 
- 5. 执行同步代码块


**释放锁** 

偏向锁的释放采用了一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。偏向锁的撤销需要等待全局安全点（这个时间点是上没有正在执行的代码）。其步骤如下： 


- 1. 暂停拥有偏向锁的线程，判断锁对象石是否还处于被锁定状态； 
- 2. 撤销偏向锁，恢复到无锁状态（01）或者轻量级锁的状态；


讲到这里，我们再回过头来看下Synchronized锁的具体流程：

- 第一步，检查MarkWord里面是不是放的自己的ThreadId ,如果是，表示当前线程是处于 “偏向锁” 
- 第二步，如果MarkWord不是自己的ThreadId,锁升级，这时候，用CAS来执行切换，新的线程根据MarkWord里面现有的ThreadId，通知之前线程暂停，之前线程将Markword的内容置为空。 
- 第三步，两个线程都把对象的HashCode复制到自己新建的用于存储锁的记录空间，接着开始通过CAS操作，把共享对象的MarKword的内容修改为自己新建的记录空间的地址的方式竞争MarkWord, 
- 第四步，第三步中成功执行CAS的获得资源，失败的则进入自旋 
- 第五步，自旋的线程在自旋过程中，成功获得资源(即之前获的资源的线程执行完成并释放了共享资源)，则整个状态依然处于 轻量级锁的状态，如果自旋失败 
第六步，进入重量级锁的状态，这个时候，自旋的线程进行阻塞，等待之前线程执行完成并唤醒自己。



总结：

![](https://i.imgur.com/HsAHoTt.png)

![](https://images2018.cnblogs.com/blog/1278254/201804/1278254-20180411013000085-1325243793.png)

![](http://images2015.cnblogs.com/blog/820406/201604/820406-20160424163618101-624122079.png)









#### 2.独占锁/共享锁 ####

独享锁是指该锁一次只能被一个线程所持有。共享锁是指该锁可被多个线程所持有。对于Java，Synchronized、ReentrantLock是独占锁；ReadWriteLock其读锁是共享锁，其写锁是独占锁。

#### 3.乐观锁/悲观锁 ####

乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。


- 悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。**（悲观锁适合写操作非常多的场景，悲观锁在Java中的使用，就是利用各种锁。）**


- 乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。**（乐观锁适合读操作非常多的场景，乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。）**


#### 4.公平锁/非公平锁 ####

公平锁与非公平锁是按照锁的获取顺序来划分的。

- 公平锁是指多个线程按照申请锁的顺序来获取锁。
- 非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。（非公平锁的优点在于吞吐量比公平锁大。）

（说明：对于Java，Synchronized是一种非公平锁，但ReentranLock可以通过构造函数指定该锁是否是公平锁，默认是非公平锁）

#### 5.分段锁 ####

分段锁其实是一种锁的设计，并不是具体的一种锁。**ConcurrentHashMap**就是通过分段锁的形式来实现高效的并发操作。下面以ConcurrentHashMap来说一下分段锁的含义以及设计思想：ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock)。当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。**分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。**

#### 6.可重入锁 ####

可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。（对于Java，Synchronized和ReentranLock都是一个可重入锁，可重入锁的一个好处是可一定程度避免死锁。）

	synchronized void setA() throws Exception{
	    Thread.sleep(1000);
	    setB();
	}
	
	synchronized void setB() throws Exception{
	    Thread.sleep(1000);
	}

上面的代码就是一个可重入锁的一个特点，如果不是可重入锁的话，setB可能不会被当前线程执行，可能造成死锁。





### （二）、锁优化 ###




- 减少锁持有时间
- 减小锁粒度
- 锁分离
- 锁粗化
- 锁消除：锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步但是被检测到不可能存在共享数据竞争的锁进行消除。