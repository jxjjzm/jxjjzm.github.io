### Jvm之自动内存管理机制(内存分配、垃圾回收) ###
***

![一张图读懂一切](https://img-blog.csdn.net/20180808112156511?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1eXV5YW5nNjY4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

### 一、Java内存区域 ###

![Java虚拟机运行时数据区](http://wiki.jikexueyuan.com/project/java-vm/images/jvm.gif)

#### 1、运行时数据区域 ####

Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范（第2版）》的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域，如图所示：

![](http://images2015.cnblogs.com/blog/908514/201607/908514-20160728214131481-348733061.jpg)

#### I、Program Couter Register(程序计数器) ####

程序计数器（Program Counter Register），也有称作为PC寄存器。想必学过汇编语言的朋友对程序计数器这个概念并不陌生，在汇编语言中，程序计数器是指CPU中的寄存器，它保存的是程序当前执行的指令的地址（也可以说保存下一条指令的所在存储单元的地址），当CPU需要执行指令时，需要从程序计数器中得到当前需要执行的指令所在存储单元的地址，然后根据得到的地址获取到指令，在得到指令之后，程序计数器便自动加1或者根据转移指针得到下一条指令的地址，如此循环，直至执行完所有的指令。

虽然JVM中的程序计数器并不像汇编语言中的程序计数器一样是物理概念上的CPU寄存器，但是JVM中的程序计数器的功能跟汇编语言中的程序计数器的功能在逻辑上是等同的，也就是说是用来指示 执行哪条指令的（***注意，Java虚拟机中的程序计数器指向正在执行的字节码地址，而不是下一条***）。

（1）程序计数器可以看做是当前线程所执行的字节码的行号指示器。在JVM的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。

（2）由于JVM的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，为了在线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，独立存储，互不影响。所以，***程序计数器是线程私有的内存区域***。

（3）如果程序执行的是一个Java方法，则计数器记录的是正在执行的虚拟机字节码指令地址；如果正在执行的是一个本地（native，由C语言编写 完成）方法，则计数器的值为Undefined

（4）由于程序计数器只是记录当前指令地址，所以***程序计数器不存在内存溢出的情况***，因此，程序计数器也是所有JVM内存区域中唯一一个没有定义OutOfMemoryError的区域。

（5）程序计数器是伴随线程生而生，伴随线程死而死的。程序计数器所占用的内存空间也是很小的（内存管理中可以忽略）。

####  II、Java VM Stack(Java虚拟机栈) ####

（1）与程序计数器一样，Java虚拟机栈（Java VM Stacks）也是线程私有的，它的生命周期与线程相同。

（2）Java虚拟机栈描述的是Java方法执行的内存模型：一个线程的每个方法被执行的时候都会同时创建一个**栈帧（Statck Frame）**用于存储局部变量表、操作数栈、动态链接、方法出口和一些额外的附加信息等。每一个方法被调用直至执行完成的过程就对应的一个栈帧在虚拟机栈中从入栈到出栈的过程：当方法被调用时，栈帧在JVM栈中入栈，当方法执行完成时，栈帧出栈。

![Java虚拟机栈帧](http://dl.iteye.com/upload/picture/pic/116489/d522394a-14a5-3833-bad5-b77979f67d0d.bmp)

- **局部变量表**：
局部变量表中存储着方法的相关局部变量，包括各种基本数据类型(boolean、byte、char、short、int、float、double、long)，对象的引用（reference）等。在局部变量表中，局部变量表的容量以变量槽（Variable Slot，下称Slot）为最小单位，只有long和double类型会占用2个变量槽（Slot，对于32位机器，一个Slot就是32个bit），其它都是1个Slot。需要注意的是，局部变量表是在编译（在Java程序被编译成Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的最大局部变量表的容量）时就已经确定好的，方法运行所需要分配的空间在栈帧中是完全确定的，在方法的生命周期内都不会改变。

- **操作数栈**：
操作数栈也常被称为操作栈，它是一个后入先出栈。同局部变量表一样，操作数栈的最大深度也在编译的时候被写入到Code属性的max_stacks数据项之中。当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令向操作数栈中写入和提取内容，也就是入栈出栈操作。（操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，在编译程序代码的时候，编译器要严格保证这一点，在类校验阶段的数据流分析中还要再次验证这一项）

- **动态链接**：
每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的符号引用，这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这部分转化称为静态解析；另外一部分将在每一次的运行期间转化为直接引用，这部分称为动态链接。

- **方法返回地址**：
当一个方法被执行后，有两种方式退出这个方法：第一种方式是正常完成出口，另外一种退出方式是异常完成出口。无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息用来帮助恢复它的上层方法的执行状态（方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行到的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等）。


- **附加信息**：
虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试相关的信息，这部分信息完全取决于具体的虚拟机实现。


（3）虚拟机栈中定义了两种异常，如果线程调用的栈深度大于虚拟机允许的最大深度，则抛出**StatckOverFlowError（栈溢出）**；不过多数Java虚拟机都允许动态扩展虚拟机栈的大小(有少部分是固定长度的)，所以线程可以一直申请栈，直到内存不足，此时，会抛出 **OutOfMemoryError（内存溢出）**。


####  III、Native Method Stack(本地方法栈) ####

本地方法栈与虚拟机栈所发挥的作用是非常类似的，其区别不过是虚拟机栈为虚拟机执行Java服务，而本地方法栈则是为虚拟机使用到的Native方法服务。虚拟机规范中对本地方法栈中的方法是用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出***StackOverflowError和OutOfMemoryError异常***。


#### IV、Java Heap(Java堆) ####

Java堆区是理解Java GC机制最重要的区域，没有之一。在JVM所管理的内存中，堆区是最大的一块，堆区也是Java GC机制所管理的主要内存区域，***堆区由所有线程共享***，在虚拟机启动时创建。***堆区的存在是为了存储对象实例***，原则上讲，所有的对象都在堆区上分配内存（不过现代技术里，也不是这么绝对的，也有栈上直接分配的）。一般的，根据Java虚拟机规范规定，堆内存需要在逻辑上是连续的（在物理上不需要），在实现时，可以是固定大小的，也可以是可扩展的，目前主流的虚拟机都是可扩展的。如果在执行垃圾回收之后，仍没有足够的内存分配，也不能再扩展，将会抛出OutOfMemoryError:Java heap space异常。

***Java堆可以细分为：新生代和老年代；再细致一点的有Eden空间，From Survivor空间，To Survivor空间等。如下图所示：***


![](http://dl2.iteye.com/upload/attachment/0088/6262/6af6a224-8b2d-3f23-8b58-79263cfda9c4.png)



#### V、Method Area(方法区) ####

（1）方法区与Java堆一样，是各个线程共享的内存区域，它***用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码（动态加载OSGI）等数据***。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。（对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”，本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，对于其他虚拟机来说是不存在永久代概念的。***Java8之后已经废弃了永久代，由元空间（Metaspace）来代替：元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。***）

（2）Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样***不需要连续的内存和可以选择固定大小或可扩展大小***外，还***可以选择不实现垃圾收集***。相对而言，垃圾收集行为在这个区域是比较少出现的，这也是方法区被称为永久代的原因之一（HotSpot），但这也不代表着在方法区上完全没有垃圾收集，这个区域的***内存回收目标主要是针对常量池的回收和对类型的卸载***，条件相当苛刻，但是这部分区域的回收确实是有必要的。

（3）***运行时常量池***是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，**用于存放编译期生成的各种字面量和符号引用**，这部分内容将在类加载后存放到方法区的运行时常量池中。（运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只能在编译期产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern方法）。

（4）根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。


#### VI、Direct Memory（直接内存） ####
  直接内存并不是JVM管理的内存，可以这样理解，直接内存，就是 JVM以外的机器内存，比如，你有4G的内存，JVM占用了1G，则其余的3G就是直接内存，JDK中有一种基于通道（Channel）和缓冲区 （Buffer）的内存分配方式，将由C语言实现的native函数库分配在直接内存中，用存储在JVM堆中的DirectByteBuffer来引用。 由于直接内存收到本机器内存的限制，所以也可能出现OutOfMemoryError的异常。




### 二、GC ###

垃圾收集（Garbage Collection）通常被称为GC，它诞生于1960年MIT的Lisp语言，经过半个世纪，目前已经十分成熟了。

jvm中，程序计数器、虚拟机栈、本地方法栈都是随着线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理，因此，我们的内存垃圾回收主要集中于Java堆和方法区中，在程序运行期间这部分的内存的分配和使用都是动态的。

GC需要完成三件事情：
（1）哪些内存需要回收？
（2）什么时候回收？
（3）如何回收？

#### （一）、垃圾收集 ####
**对象存活判断**

判断对象是否存活一般有两种方式：

- ***引用计数算法***：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。

![](https://user-gold-cdn.xitu.io/2017/9/4/4c289a224cb4944e499fb5bfd33e592f?imageView2/0/w/1280/h/960)

- ***根搜索算法***：通过一系列的名为“GC Roots”的对象作为起始点，从这个节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连（用图论的话来说就是从GC Roots到这个对象不可达）时，，则证明此对象是不可用的。Java语言中是使用根搜索算法判定对象是否存活的。

![](https://user-gold-cdn.xitu.io/2017/9/4/58bfac15ca6d3076def5174ed5ca5a99?imageView2/0/w/1280/h/960)

（注：在Java语言里可作为Gc Roots的对象包括下面几种：


- 虚拟机栈（栈帧中的本地变量表）中的引用的对象。
- 方法区中的类静态属性引用的对象。
- 方法区中的常量引用的对象。
- 本地方法栈中JNI（即一般说的Native方法）的引用的对象。

）



#### （二）、垃圾（GC）收集算法 ####

#### **1.标记-清除算法** ####

![](https://i.imgur.com/6NJDPoc.jpg)

***“标记-清除”（Mark-Sweep）算法***，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。

- 标记：标记的过程其实就是，遍历所有的GC Roots，然后将所有GC Roots可达的对象标记为存活的对象。
 

- 清除：清除的过程将遍历堆中所有的对象，将没有标记的对象全部清除掉。      

回收前（程序运行时）：

![](http://images.cnitblog.com/blog/558323/201308/19222114-6435e25e050f4a2ea3230879392bdfb3.jpg)

标记阶段：

![](http://images.cnitblog.com/blog/558323/201308/19222543-1da7fb7bc5d24fd18872a267b65e939e.jpg)

清除阶段：

![](http://images.cnitblog.com/blog/558323/201308/19222820-8eca1c1518754d8fac6da532b13f746b.jpg)

**总结：**

通俗来讲，标记清除算法就是当程序运行期间，若可以使用的内存被耗尽的时候，GC线程就会被触发并将应用程序暂停，随后将依旧存活的对象标记一遍，最终再将堆中所有没被标记的对象全部清除掉，接下来便让应用程序恢复运行。

缺点：

- 效率问题：标记和清除的效率都不是很高
- 空间问题：标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当程序在以后的运行中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。


#### **2.复制算法** ####

![](https://i.imgur.com/cYBsZIf.jpg)

***“复制”（Copying）收集算法***，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

回收前（程序运行时）

![](http://images.cnitblog.com/blog/558323/201308/20004315-b6d8b69879b94b518e98b5854b12f0f1.jpg)

回收后

![](http://images.cnitblog.com/blog/558323/201308/20004628-0ff08e1b8cd04e448703b01f0461e266.jpg)

**总结：**

缺点：

- 效率问题：复制这一工作所花费的时间在对象存活率达到一定程度时将会变得不可忽略，所以复制算法要想使用，最起码对象的存活率要非常低才行。
- 空间问题：算法代价是将内存缩小为原来的一半，浪费了一半的内存。




#### **3.标记-整理（压缩）算法** ####

![](https://i.imgur.com/eLBKkGq.jpg)

***标记-整理（压缩）（Mark-Compact）算法***，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存


- 标记：它的第一个阶段与标记/清除算法是一模一样的，均是遍历GC Roots，然后将存活的对象标记。
- 整理：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。因此，第二阶段才称为整理阶段。

      

回收前（程序运行时）

![](http://images.cnitblog.com/blog/558323/201308/20201708-e2248836524b42a18be06f1316b31e37.jpg)

标记

![](http://images.cnitblog.com/blog/558323/201308/20210139-2062db96ff9b49309a5fedc118689bae.jpg)

整理（压缩）

![](http://images.cnitblog.com/blog/558323/201308/20210241-d6498896c30f4aed94443b65c476a797.jpg)

**总结：**

标记/整理算法不仅可以弥补标记/清除算法当中不连续内存碎片的缺点，也消除了复制算法当中内存减半的高额代价，可谓是一举两得。

缺点：

- 效率问题：效率也不高。



#### **4.分代-收集算法** ####

“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。

![](https://img-blog.csdn.net/20180807234704580?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1eXV5YW5nNjY4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

在这些区域的垃圾回收大概有如下几种情况：



- 大多数情况下，新的对象都分配在Eden区，当Eden区没有空间进行分配时，将进行一次Minor GC，清理Eden区中的无用对象。清理后，Eden和From Survivor中的存活对象如果小于To Survivor的可用空间则进入To Survivor，否则直接进入老年代）；Eden和From Survivor中还存活且能够进入To Survivor的对象年龄增加1岁（虚拟机为每个对象定义了一个年龄计数器，每执行一次Minor GC年龄加1），当存活对象的年龄到达一定程度（默认15岁）后进入老年代，可以通过-XX:MaxTenuringThreshold来设置年龄的值。



- 当进行了Minor GC后，Eden还不足以为新对象分配空间（那这个新对象肯定很大），新对象直接进入老年代。



- 占To Survivor空间一半以上且年龄相等的对象，大于等于该年龄的对象直接进入老年代，比如Survivor空间是10M，有几个年龄为4的对象占用总空间已经超过5M，则年龄大于等于4的对象都直接进入老年代，不需要等到MaxTenuringThreshold指定的岁数。



- 在进行Minor GC之前，会判断老年代最大连续可用空间是否大于新生代所有对象总空间，如果大于，说明Minor GC是安全的，否则会判断是否允许担保失败，如果允许，判断老年代最大连续可用空间是否大于历次晋升到老年代的对象的平均大小，如果大于，则执行Minor GC，否则执行Full GC。



- 当在java代码里直接调用System.gc()时，会建议JVM进行Full GC，但一般情况下都会触发Full GC，一般不建议使用，尽量让虚拟机自己管理GC的策略。



- 永久代（方法区）中用于存放类信息，jdk1.6及之前的版本永久代中还存储常量、静态变量等，当永久代的空间不足时，也会触发Full GC，如果经过Full GC还无法满足永久代存放新数据的需求，就会抛出永久代的内存溢出异常。



- 大对象（需要大量连续内存的对象）例如很长的数组，会直接进入老年代，如果老年代没有足够的连续大空间来存放，则会进行Full GC。

***GC算法总结：***

- 效率（时间复杂度）： 复制算法 > 标记整理算法 > 标记清除算法
- 内存整齐度： 复制算法 = 标记整理算法 > 标记清除算法
- 内存利用率： 标记整理算法 = 标记清除算法 > 复制算法





### （三）、垃圾（GC）收集器 ###

![](http://images.cnitblog.com/blog/558323/201308/24191821-c3e4d156f40e46e7aa8f5c23ae017903.jpg)


#### **1.Serial收集器**  ####
Serial收集器是最基本、历史最悠久的收集器，曾经（在JDK 1.3.1之前）是虚拟机新生代收集的唯一选择。

- GC算法：复制算法
- 内存区域：针对新生代设计
- 执行方式：单线程、串行
- 执行过程：当新生代内存不够用时，先暂停全部用户程序，然后开启一条GC线程使用复制算法对垃圾进行回收，这一过程中可能会有一些对象提升到年老代
- 特点：由于单线程运行，且整个GC阶段都要暂停用户程序，因此会造成应用程序停顿时间较长，但对于小规模的程序来说，却非常适合。
- 适用场景：平时的开发与调试程序使用，以及桌面应用交互程序。
- 开启参数：-XX:+UseSerialGC（client模式默认值） 

![](http://images2015.cnblogs.com/blog/331425/201606/331425-20160624174239719-1127409322.png)



#### **2.ParNew收集器** ####
ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余的行为包括Serial收集器可用的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一样，实现上这两种收集器也共用了相当多的代码。


- 算法：采用复制算法
- 内存区域：针对新生代设计
- 执行方式：多线程、并行
- 执行过程：当新生代内存不够用时，先暂停全部用户程序，然后开启若干条GC线程使用复制算法并行进行垃圾回收，这一过程中可能会有一些对象提升到年老代
- 特点：采用多线程并行运行，因此会对系统的内核处理器数目比较敏感，至少需要多于一个的处理器，有几个处理器就会开几个线程（不过线程数是可以使用参数-XX:ParallelGCThreads=<N>控制的），因此只适合于多核多处理器的系统。尽管整个GC阶段还是要暂停用户程序，但多线程并行处理并不会造成太长的停顿时间。因此就吞吐量来说，ParNew要大于serial，在处理器越多的时候，效果越明显。但是这并非绝对，对于单个处理器来说，由于并行执行的开销（比如同步），ParNew的性能将会低于serial搜器。不仅是单个处理器的时候，如果在容量较小的堆上，甚至在两个处理器的情况下，ParNew的性能都并非一定可以高过serial。
- 适用场景：在中到大型的堆上，且系统处理器至少多于一个的情况
- 开启参数：-XX:+UseParNewGC -XX:ParallelGCThreads 限制线程数量


![](https://user-gold-cdn.xitu.io/2017/9/4/15465fb2e17cb5d665c25bb98acfea93?imageView2/0/w/1280/h/960)

#### **3.Parallel Scavenge收集器** ####

Parallel Scavenge收集器（下称PS收集器）也是一个多线程收集器，也是使用复制算法，但它的对象分配规则与回收策略都与ParNew收集器有所不同，它是以吞吐量（吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间)）最大化（即GC时间占总运行时间最小）为目标的收集器实现，它允许较长时间的STW换取总吞吐量最大化。开启参数：-XX:+UseParallelGC (备注：server模式下默认的新生代搜集器)

Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX：MaxGCPauseMillis参数及直接设置吞吐量大小的-XX：GCTimeRatio参数。Parallel　Scavenge还有一个参数-XX：+UseAdaptivePolicy值得关注。这是一个开关参数，当这个参数打开后，就不需要手工指定新生代（-Xmn）、Eden与Survivor区的比例（-XX：SurivorRatio）、晋升老年代对象年龄（-XX：PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量，这种调节方式称为GC自适应的调节策略（GC Ergonomics）。




#### **4.Serial Old收集器** ####
Serial Old是Serial收集器的老年代版本，他同样是一个单线程收集器，使用“标记-整理”算法。这个收集器的主要意义也是被Clent模式下的虚拟机使用。如果在Server模式下，它主要还有两大用途：一个是在JDK1.5及之前的版本中与Parallel Scavenge 收集器搭配使用，另外一个就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure的时候使用。

![](https://user-gold-cdn.xitu.io/2017/9/4/b18494b1e54851bbbd2ee52760cc3754?imageView2/0/w/1280/h/960)

#### **5.Parallel Old收集器** ####

 老年代版本吞吐量优先收集器，Parallel Old与Parallel Scavenge的关系就好似serial与serial old一样，相互之间的区别并不大，只不过parallel old是针对年老代设计的并行搜集器而已，它采用标记/整理算法。JVM 1.6提供，在此之前，新生代使用了Parallel Scavenge收集器的话，老年代除Serial Old外别无选择，因为Parallel Scavenge无法与CMS收集器配合工作。 开启参数：-XX:-UseParallelOldGC （dk7、jdk8默认使用该收集器作为老年代收集器，使用 -XX:+UseParallelOldGC来指定使用Paralle Old收集器。）

![](https://user-gold-cdn.xitu.io/2017/9/4/25641366b43d971310a0a7cede4e406a?imageView2/0/w/1280/h/960)


#### **6.CMS收集器** ####

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器是唯一一个真正意义上实现了应用程序与GC线程一起工作的收集器。CMS收集器是针对老年代设计的收集器，并采用标记清除算法，它也是唯一一个在老年代采用标记清除算法的收集器。

从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括：

![](https://user-gold-cdn.xitu.io/2017/9/4/6f4d683644a154537b3e23d60d49c074?imageView2/0/w/1280/h/960)

- 初始标记（CMS initial mark）:需要暂停应用程序，初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快;
- 并发标记（CMS concurrent mark）:恢复应用程序，并发标记阶段就是进行GC Roots Tracing的过程,标记出全部的垃圾对象，耗时较长 ;
- 重新标记（CMS remark）:需要暂停应用程序，重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短；
- 并发清除（CMS concurrent sweep）:恢复应用程序，用标记-清除算法清除垃圾对象，耗时较长。

由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行。老年代收集器（新生代使用ParNew）。



- 优点：并发收集，低停顿
- 缺点：（1）产生大量空间碎片，并发阶段会降低吞吐量；（2）CMS收集器对CPU资源很敏感，其实面向并发设计的程序都对CPU资源比较敏感；（3）CMS收集器无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC 的产生。（由于CMS并发清理阶段用户线程还在运行着，伴随程序的运行自然还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在本次收集中处理掉他们，只好留待下一次GC时再将其清理掉，这一部分垃圾就称为浮动垃圾。）
- 参数控制：（1）-XX:+UseConcMarkSweepGC  使用CMS收集器； （2）-XX:+ UseCMSCompactAtFullCollection Full GC后进行一次碎片整理，整理过程是独占的，会引起停顿时间变长；（3）-XX:+CMSFullGCsBeforeCompaction  设置进行几次Full GC后，进行一次碎片整理；-XX:ParallelCMSThreads  设定CMS的线程数量（一般情况约等于可用CPU数量）

#### **7.G1收集器（Garbage First）**  ####

G1收集器是垃圾收集器理论进一步发展的产物，是目前技术发展的最前沿成果之一，现在已经成为jdk9默认的收集器。G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。(JVM启动时会自动设置每个区域的大小（1M~32M，必须是2的次幂），最多可以设置2048个区域（即支持的最大堆内存为32M*2048=64G），假如设置-Xmx8g -Xms8g，则每个区域大小为8g/2048=4M)通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。

它与前面的CMS收集器相比有两个显著的改进：

- 一是G1收集器是基于“标记-整理（压缩）”算法实现的收集器，也就是说它不会产生空间碎片，这对于长时间运行的应用系统来说非常重要。
- 二是它可以非常精确的控制停顿，既能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集的时间不得超过N毫秒，这几乎已经是实时Java的垃圾收集器的特征了。（G1收集器可以实现在基于不牺牲吞吐量的前提下完成低停顿的内存回收，这是由于它能够极力地避免全区域的垃圾收集，**之前的收集器进行收集的范围都是整个新生代或老年代，而G1将整个Java堆（包括新生代、老年代）划分为多个大小固定的独立区域（Region）,并且跟踪这些区域里面的垃圾堆积程度，在后台维护一个优先列表，每次根据允许的收集时间，优先回收垃圾最多的区域（这就是Garbage First名称的由来），区域划分及有优先级的区域回收，保证了G1收集器在有限的时间内可以获得最高的收集效率。**）

![](http://images2015.cnblogs.com/blog/331425/201606/331425-20160624174247125-2073079982.jpg)

收集步骤：

![](https://github.com/CyC2018/Interview-Notebook/raw/master/pics/f99ee771-c56f-47fb-9148-c0036695b5fe.jpg)



- 初始标记：标记出GC Roots直接关联的对象，这个阶段速度较快，需要停止用户线程，单线程执行 
- 并发标记：从GC Root开始对堆中的对象进行可达新分析，找出存活对象，这个阶段耗时较长，但可以和用户线程并发执行 
- 最终标记：修正在并发标记阶段引用户程序执行而产生变动的标记记录 
- 筛选回收：筛选回收阶段会对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来指定回收计划（用最少的时间来回收包含垃圾最多的区域，这就是Garbage First的由来——第一时间清理垃圾最多的区块），这里为了提高回收效率，并没有采用和用户线程并发执行的方式，而是停顿用户线程。

#### **8.常用的收集器组合及垃圾收集器参数总结**  ####

- 常用的收集器组合：（1）Serial + Serial Old（2）Serial + (CMDS+Serial Old)（3）ParNew + CMS（4）ParNew + Serial Old（5）Parallel Scavenge + Seria Old（6）Parallel Scavenge + Paral Old（7）G1 + G1

- 垃圾收集相关的常用参数：
![](https://i.imgur.com/25I8jxL.png)


### （四）、内存分配与回收策略 ###


这里所说的内存分配，主要指的是在堆上的分配，一般的，对象的内存分配都是在堆上进行，但现代技术也支持将对象拆成标量类型（标量类型即原子类型，表示单个值，可以是基本类型或String等），然后在栈上分配，在栈上分配的很少见，我们这里不考虑。　Java内存分配和回收的机制概括的说，就是：***分代分配，分代回收***。对象将根据存活的时间被分为：年轻代（Young Generation）、年老代（Old Generation）、永久代（Permanent Generation，也就是方法区（java8以后废弃））。　

![](http://images2015.cnblogs.com/blog/331425/201606/331425-20160623115841781-223449019.png)

**控制参数**


- -Xms设置堆的最小空间大小。
- -Xmx设置堆的最大空间大小。
- -XX:NewSize设置新生代最小空间大小。
- -XX:MaxNewSize设置新生代最大空间大小。
- -XX:PermSize设置永久代最小空间大小。
- -XX:MaxPermSize设置永久代最大空间大小。
- -Xss设置每个线程的堆栈大小。



***年轻代（Young Generation）***：对象被创建时，内存的分配首先（优先）发生在年轻代（大对象可以直接被创建在年老代），大部分的对象在创建后很快就不再使用，因此很快变得不可达，于是被年轻代的GC机制清理掉（IBM的研究表明，98%的对象都是很快消亡的），这个GC机制被称为Minor GC或叫Young GC。（注意，Minor GC并不代表年轻代内存不足，它事实上只表示在Eden区上的GC。）年轻代上的内存分配是这样的，年轻代可以分为3个区域：Eden区和两个存活区（Survivor 0 、Survivor 1），GC算法一般采用复制算法。内存分配过程如图所示：　

![](http://www.importnew.com/wp-content/uploads/2012/12/Figure-3-Before-After-a-GC.png)



- 绝大多数刚创建的对象会被分配在Eden区，其中的大多数对象很快就会消亡。
- 当Eden区满的时候，执行Minor GC，将消亡的对象清理掉，并将存活的对象复制到一个存活区Survivor0（此时，Survivor1是空白的，两个Survivor总有一个是空白的）；此后，每次Eden区满了，就执行一次Minor GC，并将剩余的对象都复制到同一个存活区Survivor0。
- 当Survivor0也满的时候，将其中仍然活着的对象直接复制到Survivor1，以后Eden区执行Minor GC后，就将剩余的对象添加存活区Survivor1（此时，Survivor0是空白的）。
- 当几次Young GC（HotSpot虚拟机默认15次，用-XX:MaxTenuringThreshold控制，大于该值进入老年代）之后，仍然存活的对象（其实只有一小部分，比如，我们自己定义的对象），将被复制到老年代。


**年老代（Old Generation）**：对象如果在年轻代存活了足够长的时间而没有被清理掉（即在几次 Young GC后存活了下来，HotSpot虚拟机默认15次，用-XX:MaxTenuringThreshold控制，大于该值进入老年代），则会被复制到年老代，年老代的空间一般比年轻代大，能存放更多的对象，在年老代上发生的GC次数也比年轻代少。当年老代内存不足时， 将执行Major GC，也叫 Full GC（老年代一般使用标记清除算法或标记复制算法）。

- 如果对象比较大（比如长字符串或大数组），Young空间不足，则大对象会直接分配到老年代上（大对象可能触发提前GC，应少用，更应避免使用短命的大对象）。用-XX:PretenureSizeThreshold来控制直接升入老年代的对象大小，大于这个值的对象会直接分配在老年代上。（为了能够更好的适应不同程序的内存状况，虚拟机并不总是要求对象的年龄必须达到-XX:MaxTenuringThreshold才能晋升老年代，如果Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等待-XX:MaxTenuringThreshold中要求的年龄）
- 可能存在年老代对象引用新生代对象的情况，如果需要执行Young GC，则可能需要查询整个老年代以确定是否可以清理回收，这显然是低效的。解决的方法是，年老代中维护一个512 byte的块——”card table“，所有老年代对象引用新生代对象的记录都记录在这里。Young GC时，只要查这里即可，不用再去查全部老年代，因此性能大大提高。
- 新生代空间内存担保老年代：在发生Yong GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则改为直接进行一次Full GC。如果小于，则查看HandlePromotionFailure设置是否允许担保失败；如果允许，那只会进行Yong GC；如果不允许，则也要改为进行一次Full GC。


附录：




- [JVM知识点精华汇总](https://mp.weixin.qq.com/s/Km_EVow1_R-lztvmq7uMnw)
- [Java虚拟机](https://github.com/CyC2018/Interview-Notebook/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md)
- [你假笨](https://mp.weixin.qq.com/mp/homepage?__biz=MzIzNjI1ODc2OA==&hid=3&sn=bca0355516d60449a140b8ad12f3d89f#wechat_redirect)
-  [匠心零度](http://mp.weixin.qq.com/mp/homepage?__biz=MzU2NjIzNDk5NQ==&hid=1&sn=41380a4a375614ac10eda44613795dd0&scene=1&devicetype=android-24&version=26060739&lang=zh_CN&nettype=WIFI&ascene=7&session_us=gh_934b01732546&wx_header=1)





























