###Jvm之自动内存管理机制(内存分配、垃圾回收)
***
###一、Java内存区域

![Java虚拟机运行时数据区](http://wiki.jikexueyuan.com/project/java-vm/images/jvm.gif)

####1、运行时数据区域

Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范（第2版）》的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域，如图所示：

![](http://images2015.cnblogs.com/blog/908514/201607/908514-20160728214131481-348733061.jpg)

#####I、Program Couter Register(程序计数器)
程序计数器（Program Counter Register），也有称作为PC寄存器。想必学过汇编语言的朋友对程序计数器这个概念并不陌生，在汇编语言中，程序计数器是指CPU中的寄存器，它保存的是程序当前执行的指令的地址（也可以说保存下一条指令的所在存储单元的地址），当CPU需要执行指令时，需要从程序计数器中得到当前需要执行的指令所在存储单元的地址，然后根据得到的地址获取到指令，在得到指令之后，程序计数器便自动加1或者根据转移指针得到下一条指令的地址，如此循环，直至执行完所有的指令。

虽然JVM中的程序计数器并不像汇编语言中的程序计数器一样是物理概念上的CPU寄存器，但是JVM中的程序计数器的功能跟汇编语言中的程序计数器的功能在逻辑上是等同的，也就是说是用来指示 执行哪条指令的（***注意，Java虚拟机中的程序计数器指向正在执行的字节码地址，而不是下一条***）。

（1）程序计数器可以看做是当前线程所执行的字节码的行号指示器。在JVM的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。

（2）由于JVM的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，为了在线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，独立存储，互不影响。所以，***程序计数器是线程私有的内存区域***。

（3）如果程序执行的是一个Java方法，则计数器记录的是正在执行的虚拟机字节码指令地址；如果正在执行的是一个本地（native，由C语言编写 完成）方法，则计数器的值为Undefined

（4）由于程序计数器只是记录当前指令地址，所以***程序计数器不存在内存溢出的情况***，因此，程序计数器也是所有JVM内存区域中唯一一个没有定义OutOfMemoryError的区域。

（5）程序计数器是伴随线程生而生，伴随线程死而死的。程序计数器所占用的内存空间也是很小的（内存管理中可以忽略）。

#####II、Java VM Stack(Java虚拟机栈)
（1）与程序计数器一样，Java虚拟机栈（Java VM Stacks）也是线程私有的，它的生命周期与线程相同。

（2）Java虚拟机栈描述的是Java方法执行的内存模型：一个线程的每个方法被执行的时候都会同时创建一个**栈帧（Statck Frame）**用于存储局部变量表、操作数栈、动态链接、方法出口和一些额外的附加信息等。每一个方法被调用直至执行完成的过程就对应的一个栈帧在虚拟机栈中从入栈到出栈的过程：当方法被调用时，栈帧在JVM栈中入栈，当方法执行完成时，栈帧出栈。

![Java虚拟机栈帧](http://i.imgur.com/OE4Fqfs.png)

- **局部变量表**：
局部变量表中存储着方法的相关局部变量，包括各种基本数据类型，对象的引用，返回地址等。在局部变量表中，局部变量表的容量以变量槽（Variable Slot，下称Slot）为最小单位，只有long和double类型会占用2个变量槽（Slot，对于32位机器，一个Slot就是32个bit），其它都是1个Slot。需要注意的是，局部变量表是在编译时就已经确定好的，方法运行所需要分配的空间在栈帧中是完全确定的，在方法的生命周期内都不会改变。

- **操作数栈**：
操作数栈也常被称为操作栈，它是一个后入先出栈。同局部变量表一样，操作数栈的最大深度也在编译的时候被写入到Code属性的max_stacks数据项之中。当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令向操作数栈中写入和提取内容，也就是入栈出栈操作。（操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，在编译程序代码的时候，编译器要严格保证这一点，在类校验阶段的数据流分析中还要再次验证这一项）

- **动态链接**：
每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的符号引用，这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这部分转化称为静态解析；另外一部分将在每一次的运行期间转化为直接引用，这部分称为动态链接。

- **方法返回地址**：
当一个方法被执行后，有两种方式退出这个方法：第一种方式是正常完成出口，另外一种退出方式是异常完成出口。无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息用来帮助恢复它的上层方法的执行状态（方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行党的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等）。


- **附加信息**：
虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试相关的信息，这部分信息完全取决于具体的虚拟机实现。


（3）虚拟机栈中定义了两种异常，如果线程调用的栈深度大于虚拟机允许的最大深度，则抛出**StatckOverFlowError（栈溢出）**；不过多数Java虚拟机都允许动态扩展虚拟机栈的大小(有少部分是固定长度的)，所以线程可以一直申请栈，知道内存不足，此时，会抛出 **OutOfMemoryError（内存溢出）**。


#####III、Native Method Stack(本地方法栈)
本地方法栈与虚拟机栈所发挥的作用是非常类似的，其区别不过是虚拟机栈为虚拟机执行Java服务，而本地方法栈则是为虚拟机使用到的Native方法服务。虚拟机规范中对本地方法栈中的方法是用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出***StackOverflowError和OutOfMemoryError异常***。


#####IV、Java Heap(Java堆)
Java堆区是理解Java GC机制最重要的区域，没有之一。在JVM所管理的内存中，堆区是最大的一块，堆区也是Java GC机制所管理的主要内存区域，***堆区由所有线程共享***，在虚拟机启动时创建。***堆区的存在是为了存储对象实例***，原则上讲，所有的对象都在堆区上分配内存（不过现代技术里，也不是这么绝对的，也有栈上直接分配的）。一般的，根据Java虚拟机规范规定，堆内存需要在逻辑上是连续的（在物理上不需要），在实现时，可以是固定大小的，也可以是可扩展的，目前主流的虚拟机都是可扩展的。如果在执行垃圾回收之后，仍没有足够的内存分配，也不能再扩展，将会抛出OutOfMemoryError:Java heap space异常。

***Java堆可以细分为：新生代和老年代；再细致一点的有Eden空间，From Survivor空间，To Survivor空间等。如下图所示：***


![](https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&quality=100&size=b4000_4000&sec=1504256295&di=ee94ee0a2df287d4d69076a27bd81643&src=http://www.th7.cn/d/file/p/2016/11/03/bdff41f4bd948d091c007848ebb7758d.jpg)



#####V、Method Area(方法区)
（1）方法区与Java堆一样，是各个线程共享的内存区域，它***用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据***。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。（对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”，本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，对于其他虚拟机来说是不存在永久代概念的。***Java8之后已经废弃了永久代，由元空间（Metaspace）来代替：元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。***）

（2）Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样***不需要连续的内存和可以选择固定大小或可扩展大小***外，还***可以选择不实现垃圾收集***。相对而言，垃圾收集行为在这个区域是比较少出现的，这也是方法区被称为永久代的原因之一（HotSpot），但这也不代表着在方法区上完全没有垃圾收集，这个区域的***内存回收目标主要是针对常量池的回收和对类型的卸载***，条件相当苛刻，但是这部分区域的回收确实是有必要的。

（3）***运行时常量池***是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。（运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只能在编译期产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern方法）。

（4）根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。


#####VI、Direct Memory（直接内存）
  直接内存并不是JVM管理的内存，可以这样理解，直接内存，就是 JVM以外的机器内存，比如，你有4G的内存，JVM占用了1G，则其余的3G就是直接内存，JDK中有一种基于通道（Channel）和缓冲区 （Buffer）的内存分配方式，将由C语言实现的native函数库分配在直接内存中，用存储在JVM堆中的DirectByteBuffer来引用。 由于直接内存收到本机器内存的限制，所以也可能出现OutOfMemoryError的异常。




###二、GC

GC需要完成三件事情：
（1）哪些内存需要回收？
（2）什么时候回收？
（3）如何回收？

####（一）、垃圾收集
#####对象存活判断
判断对象是否存活一般有两种方式：

- ***引用计数算法***：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。

- ***根搜索算法***：通过一系列的名为“GC Roots”的对象作为起始点，从这个节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连（用图论的话来说就是从GC Roots到这个对象不可达）时，，则证明此对象是不可用的。Java语言中是使用根搜索算法判定对象是否存活的。

（注：在Java语言里可作为Gc Roots的对象包括下面几种：


- 虚拟机栈（栈帧中的本地变量表）中的引用的对象。
- 方法区中的类静态属性引用的对象。
- 方法区中的常量引用的对象。
- 本地方法栈中JNI（即一般说的Native方法）的引用的对象。

）



####（二）、垃圾（GC）收集算法

#####**1.标记-清除算法**

![](https://i.imgur.com/6NJDPoc.jpg)

***“标记-清除”（Mark-Sweep）算法***，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。

- 标记：标记的过程其实就是，遍历所有的GC Roots，然后将所有GC Roots可达的对象标记为存活的对象。
 

- 清除：清除的过程将遍历堆中所有的对象，将没有标记的对象全部清除掉。      

回收前（程序运行时）：

![](http://images.cnitblog.com/blog/558323/201308/19222114-6435e25e050f4a2ea3230879392bdfb3.jpg)

标记阶段：

![](http://images.cnitblog.com/blog/558323/201308/19222543-1da7fb7bc5d24fd18872a267b65e939e.jpg)

清除阶段：

![](http://images.cnitblog.com/blog/558323/201308/19222820-8eca1c1518754d8fac6da532b13f746b.jpg)

**总结：**

通俗来讲，标记清除算法就是当程序运行期间，若可以使用的内存被耗尽的时候，GC线程就会被触发并将应用程序暂停，随后将依旧存活的对象标记一遍，最终再将堆中所有没被标记的对象全部清除掉，接下来便让应用程序恢复运行。

缺点：

- 效率问题：标记和清除的效率都不是很高
- 空间问题：标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当程序在以后的运行中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。


#####**2.复制算法**

![](https://i.imgur.com/cYBsZIf.jpg)

***“复制”（Copying）收集算法***，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

回收前（程序运行时）

![](http://images.cnitblog.com/blog/558323/201308/20004315-b6d8b69879b94b518e98b5854b12f0f1.jpg)

回收后

![](http://images.cnitblog.com/blog/558323/201308/20004628-0ff08e1b8cd04e448703b01f0461e266.jpg)

**总结：**

通俗来讲，标记清除算法就是当程序运行期间，若可以使用的内存被耗尽的时候，GC线程就会被触发并将应用程序暂停，随后将依旧存活的对象标记一遍，最终再将堆中所有没被标记的对象全部清除掉，接下来便让应用程序恢复运行。

缺点：

- 效率问题：复制这一工作所花费的时间在对象存活率达到一定程度时将会变得不可忽略，所以复制算法要想使用，最起码对象的存活率要非常低才行。
- 空间问题：算法代价是将内存缩小为原来的一半，浪费了一半的内存。




#####**3.标记-整理（压缩）算法**

![](https://i.imgur.com/eLBKkGq.jpg)

***标记-整理（压缩）（Mark-Compact）算法***，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存


- 标记：它的第一个阶段与标记/清除算法是一模一样的，均是遍历GC Roots，然后将存活的对象标记。
- 整理：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。因此，第二阶段才称为整理阶段。

      

回收前（程序运行时）

![](http://images.cnitblog.com/blog/558323/201308/20201708-e2248836524b42a18be06f1316b31e37.jpg)

标记

![](http://images.cnitblog.com/blog/558323/201308/20210139-2062db96ff9b49309a5fedc118689bae.jpg)

整理（压缩）

![](http://images.cnitblog.com/blog/558323/201308/20210241-d6498896c30f4aed94443b65c476a797.jpg)

**总结：**

标记/整理算法不仅可以弥补标记/清除算法当中不连续内存碎片的缺点，也消除了复制算法当中内存减半的高额代价，可谓是一举两得。

缺点：

- 效率问题：效率也不高。





#####**4.分代-收集算法**

“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，


***GC算法总结：***

- 效率（时间复杂度）： 复制算法 > 标记整理算法 > 标记清除算法
- 内存整齐度： 复制算法 = 标记整理算法 > 标记清除算法
- 内存利用率： 标记整理算法 = 标记清除算法 > 复制算法





###（三）、垃圾（GC）收集器

#####**1.Serial收集器**


#####**2.ParNew收集器**


#####**3.Parallel Scavenge收集器**



#####**4.Serial Old收集器**


#####**5.Parallel Old收集器**


#####**6.CMS收集器**


#####**7.G1收集器**




###（四）、内存分配与回收策略