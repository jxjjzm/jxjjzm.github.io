### Java 数据结构与算法 ###
***

### 一、算法概述 ###

//TODO


### 二、数组与排序算法 ###

详细请参考：[十大经典排序算法](https://www.cnblogs.com/onepixel/articles/7674659.html)


### 三、哈希表 ###

//TODO

### 四、链表 ###

//TODO

### 五、栈和队列 ###

//TODO

### 六、树 ###

树是包含n(n>0)个节点的有穷集，其中：

- 存在一个唯一的节点V0,没有前驱节点，称为树的根节点；
- 任一非根节点都有且仅有一个前驱节点，被称为该节点的父节点；（任何节点都有可能有零或多个后继节点，称之为该节点的子节点）
- 任一非根节点V(k)都有且仅有一条从V(0)到该节点的路径：V(0)--->V(1)--->...--->V(k),其中V(i)是V(i-1)(1 <= i <= k)的子节点。


![](https://i.imgur.com/rSMUEP8.png)


#### （一）二叉树、完全二叉树、二叉查找树、平衡二叉树 ####

**I、二叉树**

如果树中每个节点最多只能有两个子节点，这样的树就称为“二叉树”。

**II、二叉查找树**

二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：


- 若任意结点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若任意结点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 任意结点的左、右子树也分别为二叉查找树。
- 没有键值相等的结点（no duplicate nodes）。

![](https://i.imgur.com/7zmHjgT.png)

**III、平衡二叉树（AVL Tree）**

平衡二叉树（Balanced Binary Tree）是二叉查找树的一个进化体，也是第一个引入平衡概念的二叉树。平衡二叉树（AVL树）在符合二叉查找树的条件下，还满足任何节点的两个子树的高度最大差为1。如果插入或者删除一个节点使得高度之差大于1，就要进行节点之间的旋转，将二叉树重新维持在一个平衡状态。这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)。但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多。

（这里不详细赘述具体旋转方法，有兴趣可以自行学习）

#### （二）平衡多路查找树（B树，也叫B-Tree） ####

B-树其实就是B树，B树是一种多路平衡搜索树（非二叉），若其是M路，则：


- 任意非叶子节点最多可以有M个子女，且M>2；
- 根节点的子女数为[2,M]；
- 除了根节点以外的非叶子节点的子女数目为M/2（取上整）个到M个；
- 每个节点存放至少M/2-1（取上整）和至多M-1个键值（至少两个）；
- 非叶子节点的关键字个数=指向子女的指针个数-1；
- 非叶子节点的关键字K[1],K[2],…,K[M-1]且有K[i] < K[i+1]；
- 非叶子节点的指针P[1],P[2],…,P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其他P[i]指向关键字属于(K[i-1],K[i])的子树；
- 所有叶子节点都位于同一层。

![](https://i.imgur.com/tgYGgBK.png)

（B-Tree相对于平衡二叉树（AVLTree）缩减了节点个数，使每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率。）

B-Tree是为磁盘等外存储设备设计的一种平衡查找树。系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。B-Tree结构的数据可以让系统高效的找到数据所在的磁盘块。


#### （三）B+Tree ####

B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。

从上面的B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。

B+Tree相对于B-Tree有几点不同：

- 非叶子节点只存储键值信息。
- 所有叶子节点之间都有一个链指针。
- 数据记录都存放在叶子节点中。


#### （四）红黑树 ####

红黑树，本质上来说就是一棵有序二叉树，但它在有序二叉树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n)。红黑规则：


- 每一个节点不是红色的就是黑色的。
- 根总是黑色的。
- 如果节点是红色的，则它的子节点必须是黑色的（反之则不然）。
- 从根到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（黑色高度必须相同）。

说明：	


- 重复的关键字：如果有多于一个数据项的关键字值相同，把有相同关键字的数据项分配到其他也有相同关键字数据项的两侧是很重要的。这也就是说，如果关键字的序列为50，50，50，要把第二个50放到第一个50的右边，并且把第三个50放到第一个50的左边。否则，树将不平衡。
- 修正违规的情况：假设出现违反红黑规则情况，如何修正才能使树遵守上述规则呢？有两个，而且只有这两个可能的修正措施：
	- 改变节点的颜色。
	- 执行旋转操作。



![](https://github.com/julycoding/The-Art-Of-Programming-By-July/raw/master/ebook/images/rbtree/1.png)

[---> 教你透彻了解红黑树](https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md)

#### （五）2-3-4树 ####
2-3-4树名字中的2，3，4的含义是指一个节点可能含有的子节点的个数。对非叶节点有三种可能的情况：
- 有一个数据项的节点总是有两个子节点；
- 有两个数据项项的节点总是有三个子节点；
- 有三个数据项道德节点总是有四个子节点。
简而言之，非叶节点的子节点数（L）总是比它含有的数据项（D）多1.（L=D+1）

![](https://i.imgur.com/89mhoCu.png)

2-3-4树的组织：

![](https://i.imgur.com/PHTBSSm.png)



### 六、堆和图 ###