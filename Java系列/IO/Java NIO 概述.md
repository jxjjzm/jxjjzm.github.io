### Java NIO 概述 ###
***

### 一、Linux网络IO模型简介 ###
在正式介绍网络IO模型之前，先不得不来看一下一个很多人容易混淆的几个概念：

- 同步与异步：同步和异步关注的是消息通信机制。
	- 所谓同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回，但是一旦调用返回，就得到返回值了。换句话说，就是由调用者主动等待这个调用的结果。
	- 而异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。
- 阻塞与非阻塞：阻塞和非阻塞关注的是当前线程在等待调用结果（消息，返回值）时的状态（通俗来说就是当前线程能不能去执行其他任务）.
	- 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
	- 非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。


弄清了同步与异步、阻塞与非阻塞之间的区别之后，我们正式进入正题，Linux的内核将所有外部设备都看做一个文件来操作，对一个文件的读写操作会调用内核提供的系统命令，返回一个file descriptor(fd,文件描述符)。而对一个socket的读写也会有相应的描述符，称为socketfd(socket描述符)，描述符就是一个数字，它指向内核中的一个结构体（文件路径，数据区等一些属性）。根据UNIX网络编程对IO模型的分类，UNIX提供了5种IO模型，分别如下：

- 阻塞式I/O
- 非阻塞式I/O
- I/O复用
- 信号驱动式I/O
- 异步I/O

（按POSIX标准来分，IO分为同步和异步，上面的前4钟都属于同步IO，最后一种属于异步IO）

一般来说，一个IO分为两个阶段：

- 等待数据：数据可能来自其他应用程序或者网络，如果没有数据，操作系统就一直等待，应用程序就跟着等待。
- 拷贝数据：将就绪的数据从操作系统拷贝到应用程序工作区。

（在Unix系统中，操作系统的IO操作是一个系统调用recvfrom()，即一个系统调用recvfrom包含两步，等待数据就绪和拷贝数据。）

#### 1.阻塞式IO模型 ####

正如上面的IO操作的步骤，当应用程序发起IO请求之后，操作系统就要处理系统调用recvfrom()，在这个过程中，操作系统需要等待数据就绪（数据可能来自别的应用程序的输入或者网络），应用程序则不再处理别的事情，而是一直等待（即阻塞状态）数据就绪，然后操作系统完成IO操作，然后recvfrom()才方法返回，应用程序才继续执行，这就是阻塞式IO模型。

![](https://images2015.cnblogs.com/blog/795235/201612/795235-20161208175600241-333223016.png)


#### 2.非阻塞式IO模型 ####

当应用程序发起了IO请求之后，系统调用recvfrom()被执行，并且立即返回，但是返回的并不是IO处理完成的结果，而是一个特定的错误，表示IO数据没有准备好，因此不需要进行IO操作。应用程序会不停地（即轮询）执行recvfrom()系统调用，直到数据已经就绪，然后操作系统完成IO操作，recvfrom()返回成功。这个过程中，没有数据就绪时系统调用recvfrom()是立即返回的，即应用程序并没有阻塞在底层操作系统的等待数据上面，而是轮询结果。（可见阻塞IO与非阻塞IO的关键区别在于，系统调用recvfrom是否立即返回。由于轮询会消耗大量CPU时间，因此这种模式并不常用。）

![](https://images2015.cnblogs.com/blog/795235/201612/795235-20161208180531866-1294544171.png)

#### 3.IO复用模型（多路复用） ####

前面的非阻塞IO将会轮询一个IO是否可用，而IO复用则是轮询多个IO是否至少有一个可用。IO复用的关键在于select()函数。在阻塞IO中，应用程序阻塞在一个IO的内核操作上；但在多路复用中，通过select()，可以同时监听多个IO请求的内核操作，只要有任意一个IO的内核操作就绪，都可以通知select()返回，再进行系统调用recvfrom()完成IO操作。（这个过程应用程序就可以同时监听多个IO请求，这比起基于多线程阻塞式IO要先进得多，因为服务器只需要一两个线程就可以进行多客户端通信。）

![](https://images2015.cnblogs.com/blog/795235/201612/795235-20161208182733007-1325239705.png)


#### 4.信号驱动式IO模型 ####

在unix系统中，应用程序发起IO请求时，可以给IO请求注册一个信号函数，请求立即返回，操作系统底层则处于等待状态（等待数据就绪），直到数据就绪，然后通过信号通知主调程序，主调程序才去调用系统函数recvfrom()完成IO操作。（信号驱动也是一种非阻塞式的IO模型，比起上面的非阻塞式IO模型，信号驱动式IO模型不需要轮询检查底层IO数据是否就绪，而是被动接收信号，然后再调用recvfrom执行IO操作。比起多路复用IO模型来说，信号驱动IO模型针对的是一个IO的完成过程， 而多路复用IO模型针对的是多个IO同时进行时候的场景。 ）

![](https://images2015.cnblogs.com/blog/795235/201612/795235-20161208184254976-2041108433.png)



#### 5.异步IO模型 ####

异步IO模型的工作机制是，将整个IO操作（包括等待数据就绪，复制数据到应用程序工作空间）全都交给操作系统完成，操作系统完成整个过程之后，再通知应用程序。（异步IO模型跟信号驱动IO模型很相似，但是区别是信号驱动模型是在数据就绪的时候通知应用程序，应用程序再调用系统函数recvfrom进行IO操作。而异步IO模型则是数据就绪且操作系统已经将数据拷贝进应用程序运行空间之后，操作系统再通知应用程序，这个过程中应用程序不需要阻塞。）

![](https://images2015.cnblogs.com/blog/795235/201612/795235-20161208185905304-1734361836.png)


**总结：**

![](https://i.imgur.com/W1GDbhW.png)

前面四种IO模型中，应用程序都会在某一环节阻塞（即使是轮询，也算是一种阻塞），POSIX将这种IO模型称为同步IO操作；而异步IO模型，则是全权把IO操作整个过程都交给操作系统，中途无阻塞，POSIX将这种IO模型称为异步IO操作。  

![](https://images2015.cnblogs.com/blog/795235/201612/795235-20161208185934491-1881555264.png)


### 二、IO多路复用技术 ###

在IO编程过程中，当需要同时处理多个客户端接入请求时，可以利用多线程或者IO多路复用技术进行处理。IO多路复用技术通过把多个IO的阻塞复用到同一个select的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求。与传统的多线程/多进程模型比，IO多路复用的最大优势就是系统开销小，系统不需要创建新的额外进程或者线程，也不需要维护这些进程和线程的运行，降低了系统的维护工作量，节省了系统资源。

IO多路复用的主要应用场景如下：

- 服务器需要同时处理多个处于监听状态或者多个连接状态的套接字；
- 服务器需要同时处理多种网络协议的套接字。

目前支持IO多路复用的系统调用有select、pselect、poll、epoll，在Linux网络编程过程中，很长一段时间都使用select做轮询和网络事件通知，然而select的一些固有缺陷导致了它的应用受到了很大的限制，最终Linux不得不在新的内核版本中寻找select的替代方案，最终选择了epoll。epoll与select的原理比较类似，为了克服select的缺点，epoll作了很多重大改进：

- 支持一个进程打开的socket描述符（FD）不受限制（仅受限于操作系统的最大文件句柄数）。
- IO效率不会随着FD数目的增加而线性下降。
- 使用nmap加速内核与用户空间的消息传递。
- epoll的API更加简单。


### 三、NIO简介 ###

NIO到底是什么的简称？有人称之为New IO，因为它相对于之前的IO类库是新增的，所以被称为New IO，这是它的官方叫法。但是，由于之前老的IO类库是阻塞IO，New IO类库的目标就是要让Java支持非阻塞IO，所以，更多的人喜欢称之为非阻塞IO（Non-block IO）。

NIO主要有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector。传统IO基于字节流和字符流进行操作，而NIO基于Channel和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择区)用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道。

NIO和传统IO（一下简称IO）之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。


IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。


#### 1.通道（Channel） ####

Channel是一个通道，可以通过它读取和写入数据，它就像自来水管一样，网络数据通过Channel读取和写入。通道与流的不同之处在于通道是双向的，流只是在一个方向上移动（一个流必须是InputStream或者OutputStream的子类），而且通道可以用于读、写或者同时用于读写。（因为Channel是全双工的，所以它可以比流更好地映射底层操作系统的API。特别是在UNIX网络编程模型中，底层操作系统的通道都是全双工的，同时支持读写操作）

NIO中的Channel的主要实现有：

- FileChannel : 文件通道，用于操作文件I/O
- DatagramChannel : 数据报通道，用于UDP协议
- SocketChannel : 套接字通道，用于TCP协议，客户端连接服务器后，服务器和客户端都会有一个SocketChannel，就可以互相发送数据了
- ServerSocketChannel : 服务器套接字通道，用于TCP连接响应客户端连接

![](http://hi.csdn.net/attachment/201110/15/0_1318674803WGPq.gif)

#### 2.缓冲区（Buffer） ####

 
缓冲区(Buffer)就是在内存中预留指定字节数的存储空间用来对输入/输出(I/O)的数据作临时存储，这部分预留的内存空间就叫做缓冲区。缓冲区实质上是一个数组。通常它是一个字节数组（ByteBuffer），也可以使用其他种类的数组。但是一个缓冲区不仅仅是一个数组，缓冲区提供了对数据的结构化访问以及维护读写位置(limit)等信息在NIO库中，缓冲区的作用是用来临时存储数据的，所有数据都是用缓冲区处理的，可以理解为是I/O操作中数据的中转站。缓冲区直接为通道(Channel)服务，在读取数据时，它是直接读到缓冲区中的；在写入数据时，写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作。这样利用缓冲区数据来传递就可以达到对数据高效处理的目的。

![](http://img.blog.csdn.net/20160519212332738)

在NIO中主要有八种缓冲区类(其中MappedByteBuffer是专门用于内存映射的一种ByteBuffer)，最常用的缓冲区是ByteBuffer，一个ByteBuffer提供了一组功能用于操作byte数组。除了ByteBuffer，还有其他的一些缓冲区，事实上，每一种Java基本类型（除了Boolean类型）都对应有一种缓冲区，具体如下：

![](http://hi.csdn.net/attachment/201110/15/0_1318674716tv5y.gif)

缓冲区是包在一个对象内的基础数据的数组，Buffer类相比一般简单数组而言其优点是将数据的内容和相关信息放在一个对象里面，这个对象提供了处理缓冲区数据的丰富的API。所有缓冲区都有4个属性：capacity、limit、position、mark，并遵循：capacity>=limit>=position>=mark>=0，下表格是对着4个属性的解释：

- 容量（ Capacity）：缓冲区能够容纳的数据元素的最大数量，容量在缓冲区创建时被设定，并且永远不能被改变。
- 上界（Limit）：缓冲区中现存元素的计数。或者说，缓冲区中当前数据量。 
- 位置（Position）：下一个要被读或写的元素的索引。位置会自动由相应的 get( )和 put( )函数更新。 
- 标记（Mark）：一个备忘位置。调用 mark( )来设定 mark = postion。调用reset()可以让position恢复到标记的位置即position=mark。标记在设定前是未定义的(undefined)。

![](https://images2015.cnblogs.com/blog/616953/201704/616953-20170415101805533-1272238015.png)

（其中，mark未被设定，position初始为0，capacity为10，limit为10，第一个元素存放至position为0的位置，capacity不变，其他三个属性会变化。position在调用 put()时，会自动指出了下一个数据元素应该被插入的位置，或者当 get()被调用时指出下一个元素应从何处取出。注意：**缓冲区并不是多线程安全的。如果想以多线程同时存取特定的缓冲区，则需要在存取缓冲区之前进行同步**）


**操作缓冲区：**


- 存取(Buffer.get() & Buffer.put())：使用get()从缓冲区中取数据，使用put()向缓冲区中存数据。
- 翻转(Buffer.flip())：翻转就是将一个处于存数据状态的缓冲区变为一个处于准备取数据的状态，使用flip()方式实现翻转。
- 压缩(Buffer.compact())：压缩就是将已读取了的数据丢弃，保留未读取的数据并将保留的数据重新填充到缓冲区的顶部，然后继续向缓冲区写入数据。
- 标记(Buffer.mark())：标记就是记住当前位置(使用mark()方法标记)，之后可以将位置恢复到标记处(使用reset()方法恢复)。
- ......


#### 3.选择器（selector） ####

NIO中的选择器(Selector)的作用就是维护注册到选择器中的通道集合，每一个通道与选择器的关系封装在选择键(SelectionKey)中，实际上可以认为选择器维护的是选择键集合。简单来讲，Selector会不断地轮询注册在其上的Channel，如果某个Channel上面有新的TCP连接接入、读和写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以获取就绪Channel的集合，进行后续的IO操作。（一个多路复用器Selector可以同时轮询多个Channel，由于JDK使用epoll()代替传统的select实现，所以它并没有最大连接句柄1024/2048的限制。这也就意味着只需要一个线程负责Selector的轮询，就可以接入成千上万的客户端，这确实是个非常巨大的进步。）

![](http://img.blog.csdn.net/20140610015907328?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWJjX2tleQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

要使用选择器（Selector），需要创建一个Selector实例（使用静态工厂方法Selector.open()）并将其注册（register）到想要监控的通道上（注意，这要通过Channel的方法实现，而不是使用selector的方法）。最后，调用选择器的select()方法。该方法会阻塞等待，直到有一个或更多的信道准备好了I/O操作或等待超时。select()方法将返回可进行I/O操作的信道数量。现在，在一个单独的线程中，通过调用select()方法就能检查多个信道是否准备好进行I/O操作。如果经过一段时间后仍然没有信道准备好，select()方法就会返回0，并允许程序继续执行其他任务。（**注意：只有继承了SelectableChannel的类才能注册到选择器中，并且只有非阻塞模式的通道才能注册到选择器**）

Selector类主要维护三个集合：

- Registered key set(已注册键集合)：调用Selector的keys()方法可以获取；
- Selected key set(已选择键集合)：调用Selector的selectedKeys()方法获取；
- Cancelled key set(已取消键集合)：已取消键集合是Selector对象的私有成员，外部无法访问。



Selector(选择器)提供了下面方法：

- open()：打开一个选择器
- isOpen()：检查一个选择器实例是否打开
- provider()：返回一个SelectorProvider
- keys()：返回注册键集合
- selectedKeys()：返回已选择键集合
- selectNow()：立刻执行选择，非阻塞，若没有已准备好的通道则立即返回0
- select(long timeout)：执行选择，超过指定毫秒数则返回
- select()：执行选择，会一直阻塞直到有准备就绪的通道
- wakeup()：停止选择
- close()：关闭选择器


SelectionKey(选择键对象)提供了下面方法：

- channel()：获取关联的通道(SelectableChannel)
- selector()：获取关联的选择器(Selector)
- isValid()：验证维护选择器与通道关系的SelectionKey是否有效
- cancel()：取消键，调用一个已取消的键的方法将抛
- CancelledKeyException
- interestOps()：获取这个key的兴趣(可选择操作)集合
- interestOps(int ops)：设置这个key的兴趣
- readyOps()：返回这个key准备好的操作集合(兴趣集合)
- isReadable()：检查选择键的兴趣是否为可读，实际上是通道的兴趣，选择键维护通道与选择器关系
- isWritable()：检查选择键的兴趣是否为可写
- isConnectable()：检查选择键的兴趣是否为连接
- isAcceptable()：检查选择键的兴趣是否为接受
- attach(Object ob)：设置一个Object数据到此key上
- attachment()：获取设置的Object数据




### 四、NIO流程 ###

1.NIO服务端

![NIO Server](https://i.imgur.com/cnDXM2a.png)




2.NIO客户端

![NIO Client](https://i.imgur.com/5JeyC5X.png)




#### 附：不选择Java原生NIO变成的原因 ####



- （1）.NIO的类库和API复杂，使用麻烦，需要熟练掌握Selector、ServerSocketChannel、SocketChannel、ByteBuffer等。
- （2）.需要具备其他的额外技能做铺垫，例如熟悉Java多线程编程。这是因为NIO编程涉及到Reactor模式，必须对多线程和网络编程非常熟悉，才能编写出高质量的NIO程序。
- （3）.可靠性能力补齐，工作量和难度都非常大。例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常码流的处理等问题，NIO编程的特点是功能开发相对容易，但是可靠性能力补齐的工作量和难度都非常大。
- （4）.JDK NIO的BUG，例如臭名昭著的epoll bug,它会导致Selector 空轮询，最终导致CPU 100%。














