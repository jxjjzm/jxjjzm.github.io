### MySql数据库之事务 ###
***

### 一、事务的四大特性（ACID） ###

#### 1.原子性（Atomicity） ####

原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚。

#### 2.一致性（Consistency） ####
一个事务的执行不应该破坏数据库的完整性约束。（有非法数据操作，如：外键约束，事物撤回。）


#### 3.隔离性（Isolation） ####
事务独立运行。一个事务处理后的结果，影响了其他事务，那么其他事务会撤回。事务的100%隔离，需要牺牲速度。（通常来说，事务之间的行为不应该互相影响。然而实际情况中，事务相互影响的程度受到事务隔离级别的影响。）


#### 4.持久性（Durability） ####
事务提交之后，需要将提交的事务持久化到磁盘。即使系统崩溃，提交的数据也不应该丢失。（软、硬件崩溃后，InnoDB数据表驱动会利用日志文件重构修改。可靠性和高速度不可兼得， innodb_flush_log_at_trx_commit 选项 决定什么时候吧事务保存到日志里。）


备注：在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行SQL语句后就会马上执行 COMMIT操作。因此要显式地开启一个事务务须使用命令 BEGIN 或 START TRANSACTION，或者执行命令 SET AUTOCOMMIT=0，用来禁止使用当前会话的自动提交。



### 二、事务隔离级别 ###

#### 1.Read Uncommitted(读取未提交内容) ####



- 在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。
- 本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。
- 该级别引发的问题是——脏读(Dirty Read)：读取到了未提交的数据。


#### 2.Read Committed(读取提交内容) ####

- 这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。
- 它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。
- 这种隔离级别出现的问题是——不可重复读(Nonrepeatable Read)：不可重复读意味着我们在同一个事务中执行完全相同的select语句时可能看到不一样的结果。导致这种情况的原因可能有：(1)有一个交叉的事务有新commit，导致了数据的改变;(2)一个数据库被多个实例操作时,同一事务的其他实例在该实例处理其间可能会有新的commit。


#### 3.Repeatable Read(可重读) ####

- 这是MySQL的默认事务隔离级别。
- 它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。
- 此级别可能出现的问题——幻读(Phantom Read)：当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。
- InnoDB和Falcon存储引擎通过多版本并发控制(MVCC，Multiversion Concurrency Control)机制解决了该问题。


#### 4.Serializable(可串行化) ####

- 这是最高的隔离级别。
- 它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之,它是在每个读的数据行上加上共享锁。



![](http://images2015.cnblogs.com/blog/821187/201608/821187-20160811171241606-133220585.jpg)



补充：

在InnoDB存储引擎中，通过使用Next-Key Lock（间隙锁）来避免幻读问题。在Next-Key Lock（间隙锁）算法下，对于索引的扫描，不仅是锁住扫描到的索引，而且还锁住这些索引覆盖的范围（gap）.因此在这个范围内的插入都是不允许的，这样就避免了另外的事务在这个范围内插入数据导致的幻读问题。因此，InnoDB存储引擎的默认事务隔离级别是READ REPEATABLE，采用Next-Key Lock算法避免了幻读的现象。




### 三、多版本并发控制（MVCC） ###


多版本并发控制（MVCC），是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 这样在读操作不用阻塞写操作，写操作不用阻塞读操作的同时，避免了脏读和不可重复读。


InnoDB 的MVCC，是通过在每行记录后面保存两个隐藏的列来实现。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号（system version number）.每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。（MVCC只在REPEATABLE READ和READ COMMITTED两个隔离级别下工作，其他两个隔离级别都和MVCC不兼容。因为READ UNCOMMITTED总是读取最新的数据行，而不是符合当前事务版本的数据行；而SERIALIZABLE则会对所有读取的行都加锁。）





















































































































































































