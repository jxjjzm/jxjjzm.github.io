### MySql数据库之SQL优化 ###
***


### 一、Mysql之执行计划 ###

使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈。通过EXPLAIN，我们可以分析出以下结果：


- 表的读取顺序
- 数据读取操作的操作类型
- 哪些索引可以使用
- 哪些索引被实际使用
- 表之间的引用
- 每张表有多少行被优化器查询


Explain使用方式： EXPLAIN +SQL语句

#### explain 输出解释： ####


![](https://pic3.zhimg.com/80/v2-d61a9dd58e8f2760dbc94e4e5208987a_hd.jpg)


- id : select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序
	-  id相同时，执行顺序由上至下
	-  如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行
	-  id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行




- select_type: SELECT 查询的类型.
	-  SIMPLE : 简单SELECT(除子查询或者UNION 之外的其他查询)；
	-  PRIMARY : 查询中若包含任何复杂的子部分,最外层的select被标记为PRIMARY。（子查询中的最外层查询，注意并不是主键查询；）；
	-  UNION : UNION 语句中第二个SELECT 开始的后面所有SELECT，第一个SELECT 为PRIMARY；
	-  DEPENDENT UNION : 子查询中的UNION，且为UNION中从第二个SELECT开始的后面所有SELECT，依赖于外部查询的结果集；
	-  UNION RESULT : UNION 中的合并结果；
	-  SUBQUERY : 子查询内层查询的第一个SELECT，结果不依赖于外部查询结果集；
	-  DEPENDENT SUBQUERY : 子查询中内层的第一个SELECT，依赖于外部查询的结果集；
	-  DERIVED : 在FROM列表中包含的子查询被标记为DERIVED（衍生），MySQL会递归执行这些子查询，把结果放在临时表中



- table : 显示这一行的数据是关于哪张表的. 有时不是真实的表名字,看到的是derivedx(x是个数字,我的理解是第几步执行的结果)


- type : 这列很重要,显示了连接使用了哪种类别,有无使用索引. 从最好到最差的连接类型为(列举出主要的，并非全部): ALL < index < range ~ index_merge < ref < eq_ref < const < system .(一般来说，得保证查询至少达到range级别，最好能达到ref。)
	- system : 表只有一行记录（等于系统表），这是const联接类型的一个特例，平时不会出现，这个也可以忽略不计.(表仅有一行满足条件.)
	- const : 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可.
	- eq_ref : 主键或唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 =, 查询效率较高. 
	- ref : 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引扫描, 或者是使用了最左前缀 规则索引的查询. 
	- range : 扫描部分索引，表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, <>, >, >=, <, <=, IS NULL, <=>, BETWEEN, IN() 操作中.当 type 是 range 时, 那么 EXPLAIN 输出的 ref 字段为 NULL, 并且 key_len 字段是此次查询中使用到的索引的最长的那个.
	- index : 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.index 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据. 当是这种情况时, Extra 字段 会显示 Using index.
	- all : 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难. 如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免.




- possible_keys ： 显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用。


- key : key列显示MySQL实际决定使用的键（索引）。
	- 实际使用的索引，如果为NULL，则没有使用索引。（可能原因包括没有建立索引或索引失效）
	- 查询中若使用了覆盖索引（select 后要查询的字段刚好和创建的索引字段完全相同），则该索引仅出现在key列表中 ,possible_keys中不会出现



- key_len : 表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度，在不损失精确性的情况下，长度越短越好。key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的。 (这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.)

	![](https://i.imgur.com/h6H0Te5.png)

- ref : ref列显示使用哪个列或常数与key一起从表中选择行。


- rows ： rows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.
这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好.


- Extra : EXplain 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容:
	- Using filesort : 当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.
	- Using index : "覆盖索引扫描", 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错
	- Using temporary : 查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.






#### 附：参考文献 ####

- [MySQL 性能优化神器 Explain 使用分析](https://segmentfault.com/a/1190000008131735)
- [MySQL explain详解](https://www.cnblogs.com/butterfly100/archive/2018/01/15/8287569.html)
- [MySQL explain命令详解](https://www.cnblogs.com/gomysql/p/3720123.html)





### 二、Mysql使用慢查询分析 ###

在my.ini中： long_query_time=1 log-slow-queries=d:\mysql5\logs\mysqlslow.log 把超过1秒的记录在慢查询日志中 可以用mysqlsla来分析之。也可以在mysqlreport中，有如 DMS分别分析了select ,update,insert,delete,replace等所占的百分比

不要直接打开整个慢查询日志进行分析，这样比较浪费时间和精力，可以使用pt-query-digest工具进行分析.



- 使用show profile ： set profiling=1;开启，服务器上所有执行语句会记录执行时间，存到临时表中show profiles、show profile for query 临时表ID
- 使用show status ： show status会返回一些计数器，show global status会查看所有服务器级别的所有计数有时根据这些计数，可以推测出哪些操作代价较高或者消耗时间多
- show processlist : 观察是否有大量线程处于不正常的状态或特征(比如：锁等待)
- 使用explain





### 二、SQL优化基本经验 ###


#### I、索引的最左前缀原理 ####


当 B+Tree 的数据项是复合的数据结构，比如索引 (name, age, sex) 的时候，B+Tree 是按照从左到右的顺序来建立搜索树的。



- 比如当 (张三, 20, F) 这样的数据来检索的时候，B+Tree 会优先比较 name 来确定下一步的所搜方向，如果 name 相同再依次比较 age 和 sex ，最后得到检索的数据。
- 但当 (20, F) 这样的没有 name 的数据来的时候，B+Tree 就不知道下一步该查哪个节点，因为建立搜索树的时候 name 就是第一个比较因子，必须要先根据 name 来搜索才能知道下一步去哪里查询。
- 比如当 (张三, F) 这样的数据来检索时，B+Tree 可以用 name 来指定搜索方向，但下一个字段 age 的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是 F 的数据了。

这个是非常重要的性质，即索引的最左前缀原理。




#### II、索引优化策略 ####




- 最左前缀匹配原则
- 主键外检一定要建索引
- 对 where,on,group by,order by 中出现的列使用索引
- 尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0
- 对较小的数据列使用索引,这样会使索引文件更小,同时内存中也可以装载更多的索引键
- 索引列不能参与计算，保持列“干净”，比如fromunixtime(createtime) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成createtime = unixtimestamp(’2014-05-29’);
- 为较长的字符串使用前缀索引
- 尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可
- 不要过多创建索引, 权衡索引个数与DML之间关系，DML也就是插入、删除数据操作。这里需要权衡一个问题，建立索引的目的是为了提高查询效率的，但建立的索引过多，会影响插入、删除数据的速度，因为我们修改的表数据，索引也需要进行调整重建
- 对于like查询，”%”不要放在前面。
- 查询where条件数据类型不匹配也无法使用索引
- 当只要一行数据时使用 LIMIT 1




**Mysql 索引失效的可能情况**

- Null值
	- 单列索引无法存储null值，复合索引无法存储全为null的值。
	- 查询时，采用is null（is not null）条件时，不能利用到索引，只能全表扫描。

（

- 索引是有序的。NULL值进入索引时，无法确定其应该放在哪里。
- 如果需要把空值存入索引，方法有二：其一，把NULL值转为一个特定的值，在WHERE中检索时，用该特定值查找。其二，建立一个复合索引。例如　create index ind_a on table(col1,1);  通过在复合索引中指定一个非空常量值，而使构成索引的列的组合中，不可能出现全空值。　

）


- 前导模糊查询不能利用索引(like '%XX'或者like '%XX%')
- 不在索引列上做任何操作（计算，函数，（自动或者手动）类型装换），会导致索引失效而导致全表扫描
- 存储引擎不能使用索引中范围条件右边的列，范围之后索引失效。（< ,> between and）
- mysql使用不等于(!= 或者<>)的时候，无法使用索引，会导致索引失效
- mysql中，如果条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)。要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引
- mysql中，字符串不加单引号索引会失效。
- 违反最左前缀匹配原则
- 查询where条件数据类型不匹配也无法使用索引


附：

- [MySQL 大表优化方案（长文）](https://mp.weixin.qq.com/s/Z5jqnl_VnCDvbnYdboLw2A)












































































































