### 浅析Redis分布式缓存 ###
***
### 一、Redis缓存穿透 ###

缓存穿透是指查询一个一定不存在的数据，由于缓存不命中，并且出于容错考虑， 如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。

![缓存穿透](https://images2015.cnblogs.com/blog/37237/201604/37237-20160407210825672-814014417.png)

- 危害： 对底层数据源(mysql, hbase, http接口, rpc调用等等)压力过大，有些底层数据源不具备高并发性。
- 原因：可能是代码本身或者数据存在的问题造成的，也很有可能是一些恶意攻击、爬虫等等（因为http读接口都是开放的）
- 如何发现：可以分别记录cache命中数, storage命中数，以及总调用量，如果发现空命中（cache,storage都没有命中）较多，可能就会在缓存穿透问题。
- 解决思路：

![](https://images2015.cnblogs.com/blog/37237/201604/37237-20160407211050375-250491615.png)

（1）缓存空对象

如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存（有一个比较巧妙的作法是，可以将这个不存在的key预先设定一个特定值。）但它的过期时间会很短，最长不超过五分钟。

- 适用场景：数据命中不高，数据频繁变化实时性高
- 维护成本：代码比较简单，但是有两个问题：
	- 第一，空值做了缓存，意味着缓存层中存了更多的键，需要更多的内存空间 ( 如果是攻击，问题更严重 )，比较有效的方法是针对这类数据设置一个较短的过期时间，让其自动剔除。
	- 第二，缓存层和存储层的数据会有一段时间窗口的不一致，可能会对业务有一定影响。例如过期时间设置为 5 分钟，如果此时存储层添加了这个数据，那此段时间就会出现缓存层和存储层数据的不一致，此时可以利用消息系统或者其他方式清除掉缓存层中的空对象。

![](https://images2015.cnblogs.com/blog/37237/201604/37237-20160407211139984-892950876.png)

（2）bloomfilter或者压缩filter(bitmap等等)提前拦截


对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃。还有最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。

- 适用场景：数据命中不高，数据相对固定实时性低（通常是数据集较大）
- 维护成本：代码维护复杂, 缓存空间占用少

![](https://images2015.cnblogs.com/blog/37237/201604/37237-20160407211709906-1980347591.png)


### 二、Redis缓存并发 ###

![](https://images2015.cnblogs.com/blog/97364/201612/97364-20161205122820741-916410826.jpg)

缓存过期后将尝试从后端数据库获取数据，这是一个看似合理的流程。但是，在高并发场景下，有可能多个请求并发的去从数据库获取数据，对后端数据库造成极大的冲击，甚至导致 “雪崩”现象。此外，当某个缓存key在被更新时，同时也可能被大量请求在获取，这也会导致一致性的问题。那如何避免类似问题呢？我们会想到类似“锁”的机制，在缓存更新或者过期的情况下，先尝试获取到锁，当更新或者从数据库获取完成后再释放锁，其他的请求只需要牺牲一定的等待时间，即可直接从缓存中继续获取数据。

![](http://img.blog.csdn.net/20170410191029031?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzk3MDk5MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

### 三、Redis缓存一致性问题 ###

当数据时效性要求很高时，需要保证缓存中的数据与数据库中的保持一致，而且需要保证缓存节点和副本中的数据也保持一致，不能出现差异现象。这就比较依赖缓存的过期和更新策略。一般会在数据发生更改的时，主动更新缓存中的数据或者移除对应的缓存。

如何解决DB和缓存一致性问题？

![缓存不一致性常见场景及解决方案](https://images2015.cnblogs.com/blog/97364/201612/97364-20161205123019351-2007093687.png)

答：当修改了数据库后，又没有及时修改缓存。这种问题，以前有过实践，修改数据库成功，而修改缓存失败的情况，最主要就是缓存服务器挂了。而因为网络问题引起的没有及时更新，可以通过重试机制来解决。而缓存服务器挂了，请求首先自然也就无法到达，从而直接访问到数据库。那么我们在修改数据库后，无法修改缓存，这时候可以将这条数据放到数据库中，同时启动一个异步任务定时去检测缓存服务器是否连接成功，一旦连接成功则从数据库中按顺序取出修改数据，依次进行缓存最新值的修改。




![](https://user-gold-cdn.xitu.io/2018/7/9/1647c7f9ec8f1202?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### 四、缓存雪崩 ###

![缓存雪崩](https://juejin.im/post/5b42b0096fb9a04fbd1b093b?from=timeline)

缓存雪崩就是指由于缓存的原因，导致大量请求到达后端数据库，从而导致数据库崩溃，整个系统崩溃，发生灾难。导致这种现象的原因有很多种，上面提到的“缓存并发”，“缓存穿透”，“缓存颠簸”等问题，其实都可能会导致缓存雪崩现象发生。这些问题也可能会被恶意攻击者所利用。还有一种情况，例如某个时间点内，系统预加载的缓存周期性集中失效了，也可能会导致雪崩。为了避免这种周期性失效，可以通过设置不同的过期时间，来错开缓存过期，从而避免缓存集中失效。从应用架构角度，我们可以通过限流、降级、熔断等手段来降低影响，也可以通过多级缓存来避免这种灾难；从整个研发体系流程的角度，应该加强压力测试，尽量模拟真实场景，尽早的暴露问题从而防范。

解决方法：

- 在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。
- 可以通过缓存reload机制，预先去更新缓存，再即将发生大并发访问前手动触发加载缓存
- 不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀
- 做二级缓存，或者双缓存策略。A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期。

![](https://images2015.cnblogs.com/blog/97364/201612/97364-20161205123238804-1230422379.jpg)



### 五、Redis上踩过的一些坑 ###

(部分内容转载自：[Redis上踩过的一些坑-美团](http://blog.csdn.net/chenleixing/article/details/50530419)、[那些年使用缓存踩过的坑](https://mp.weixin.qq.com/s?__biz=MzI3OTUwMjM4MA%3D%3D&mid=2247483718&idx=1&sn=3324abf6b2a3245e330b35213ee922a5&chksm=eb478a05dc300313355f4e437ec701b58356c4aa19ad36c46c4031216dab3016e016bda8afee))




**案例1：缓存和DB的同步更新不在同一个事务里并且没有重试补偿机制**

场景描述：

为了减少系统间的依赖，不同系统的数据更新往往不放在同一个事务里，采用MQ来进行通信。大家可以看下图，后台系统CRM更新产品数据到DB，Product系统收到异步消息通知后，更新最新数据到缓存。这是一个最常见的缓存应用场景，我相信很多团队都是这样用的。在这个Case里容易出现的问题在于，如果批处理任务收到消息后服务crash掉了，缓存没有正常更新，就出现了与DB的数据不同步，前端系统一直不能读到最新数据，导致业务异常。

![案例1](http://mmbiz.qpic.cn/mmbiz_png/db7D8z7FCyDZViaOiaicw63St1ia5oThHrfrqPd9e0fJgeu4iab3bs4mSIbw61sfbibvbgdl2IhDcjzpbviaIiaIF5VpcA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)



解决方案：


- 1）.失败消息一定要建立一定时间间隔的重试机制
- 2） 系统要有缓存更新的报警机制，方便更新失败或者重试超时后，可以人工介入进行补偿。


**案例2： 同一数据被1个以上的服务执行写操作，其中一个服务的缓存数据没有版本控制**

场景描述：

这也是两个不同服务更新数据过程中很常见的情况，见下图，CRM系统更新了某个用户的Profile, 保存更新数据库后，通过MQ通知用户系统更新缓存，由于是异步更新延迟，在缓存更新前，用户系统收到前端的指令，读取了当前缓存里的用户数据，做了修改，并更新到DB中。出现的结果就是数据库里的CRM的更新被错误覆盖。


![案例2](http://mmbiz.qpic.cn/mmbiz_png/db7D8z7FCyDZViaOiaicw63St1ia5oThHrfr9lGCibrUCjDtLiahMr36vDqpHibZm0V4AP3ib8JcHmfWia4lLnkfov2I1zQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)



解决方案：

缓存里的数据有一个标志位可以作为更新数据库数据的依据（Update_time or Version）, 如果缓存里数据时间与数据库时间不能匹配，意味着另外一个服务更新了该数据，那么就先从DB里读取最新数据版本，然后在新版本上提交数据。




**案例3： 并发查询缓存中同一数据，如果缓存没命中，导致DB瞬时被打爆**

场景描述：

做促销活动的时候，存在大量用户的并发访问某一个特定商品，该商品数据缓存失效，或者做了数据更改，但是对应缓存还没有更新，那么所有这些访问将同时直接被作用到DB上。

![案例3](http://mmbiz.qpic.cn/mmbiz_png/db7D8z7FCyDZViaOiaicw63St1ia5oThHrfreh3hWzMNerkicCvP5dXCwCxp3FQmANvZmTTDHdS5C9O4SeUlFsdthicQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)


解决方案：

做一个计数器或者锁（没有特别复杂逻辑的话，可以直接用HashMap），如果发现某个KEY缓存没有命中，那么在计数器+1, 然后访问数据库，拿到结果更新缓存，清理掉计数器中的key。 在这个过程中，如果有第二个线程或者更多的线程需要访问这个KEY时，发现计数器的值>1 或者被加锁, 那么wait, 直到计数器清理掉，当然，这个技术器阈值是可以在配置文件里配置的，不一定是1。



**案例4：缓存没有设置默认值，被攻击，缓存一直保持在被“穿透”状态**

场景描述：

这个情况，和案例3比较类似，都是缓存无法命中，但不一样的地方在于，数据的KEY值是无法控制的，所以没法简单的用计数器和锁来处理, 比方，被人为攻击，制造的大量的无效userID访问。

解决方案：

所有没有在缓存的KEY，全部分配一个默认VALUE “UNKOWN-KEY” ，具体是什么情况下，将默认值分配给没有命中的KEY， 这个可以根据自己的业务系统来定，比方说，可以根据特定的IP段，或者没有命中的总次数等，然后我们就可以决定是否继续访问DB还是直接返回默认值给前端，拒绝本次数据访问。这种做法的核心在于，每次数据访问，都会有缓存结果返回，根据系统的情况来决定是否要进一步访问DB。


**案例5：NULL缓存穿透**

场景描述：

shop_img 缓存穿透 

解决方案：

（mysql select 7k ------> mysql global log ------> 前置redis------> 加了还有 -----> 空数据没缓存  ------> 仍然有问题 ------> 漏了一个地方）


**案例6：redis内存占用飙升**

场景描述：

redis-cluster某个分片内存飙升，明显比其他分片高很多，而且持续增长。并且主从的内存使用量并不一致。

![](http://dl2.iteye.com/upload/attachment/0112/8746/c1763302-3ce3-3aa1-ab06-b79c9a5568f9.jpg)

分析可能原因：


- （1）redis-cluster的bug （这个应该不存在）
- （2）客户端的hash(key)有问题，造成分配不均。（redis使用的是crc16, 不会出现这么不均的情况）
- （3）存在个别大的key-value: 例如一个包含了几百万数据set数据结构（这个有可能）
- （4）主从复制出现了问题。
- （5）其他..................



**案例7：**

场景描述：

周期性出现connect timeout

分析可能的原因：


- (1). 网络原因：比如是否存在跨机房、网络割接等等。
- (2). 慢查询，因为redis是单线程，如果有慢查询的话，会阻塞住之后的操作。 
- (3). value值过大？比如value几十兆，当然这种情况比较少，其实也可以看做是慢查询的一种
- (4). aof重写/rdb fork发生？瞬间会堵一下Redis服务器。
- (5). 其他..................



总结，今天列举的这几个案例，归纳起来，可以总结为以下几点：
1. 保证缓存同步
2. 减少缓存并发
3. 杜绝缓存穿透




### 五、缓存使用心得 ###



1.缓存不是DB

- 主要解决频繁的低IO速率读取
- 大多数场景不做持久化，可随时被淘汰


2.内存很珍贵

- 合理设计需要缓存的数据，避免过大数据(<20K)
- 过期时间必须设置且不要超过1周


3.命中率很重要

- 50%与95%对DB而言，相差10倍请求量




### 附录 ###

- [一篇文读懂缓存在大型分布式系统中的最佳应用](http://dbaplus.cn/news-21-969-1.html)
- [缓存的正确使用方式，你都会了吗？](https://mp.weixin.qq.com/s/wgsB3GU9rpZoV6p9xwX34A)









