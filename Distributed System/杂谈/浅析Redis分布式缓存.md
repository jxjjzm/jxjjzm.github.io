### 浅析Redis分布式缓存 ###
***
### 一、Redis缓存穿透 ###

缓存穿透是指查询一个一定不存在的数据，由于缓存不命中，并且出于容错考虑， 如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。

![缓存穿透](https://images2015.cnblogs.com/blog/37237/201604/37237-20160407210825672-814014417.png)

- 危害： 对底层数据源(mysql, hbase, http接口, rpc调用等等)压力过大，有些底层数据源不具备高并发性。
- 原因：可能是代码本身或者数据存在的问题造成的，也很有可能是一些恶意攻击、爬虫等等（因为http读接口都是开放的）
- 如何发现：可以分别记录cache命中数, storage命中数，以及总调用量，如果发现空命中（cache,storage都没有命中）较多，可能就会在缓存穿透问题。
- 解决思路：

![](https://images2015.cnblogs.com/blog/37237/201604/37237-20160407211050375-250491615.png)

（1）缓存空对象

如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存（有一个比较巧妙的作法是，可以将这个不存在的key预先设定一个特定值。）但它的过期时间会很短，最长不超过五分钟。

- 适用场景：数据命中不高，数据频繁变化实时性高
- 维护成本：代码比较简单，但是有两个问题：
	- 第一，空值做了缓存，意味着缓存层中存了更多的键，需要更多的内存空间 ( 如果是攻击，问题更严重 )，比较有效的方法是针对这类数据设置一个较短的过期时间，让其自动剔除。
	- 第二，缓存层和存储层的数据会有一段时间窗口的不一致，可能会对业务有一定影响。例如过期时间设置为 5 分钟，如果此时存储层添加了这个数据，那此段时间就会出现缓存层和存储层数据的不一致，此时可以利用消息系统或者其他方式清除掉缓存层中的空对象。

![](https://images2015.cnblogs.com/blog/37237/201604/37237-20160407211139984-892950876.png)

（2）bloomfilter或者压缩filter(bitmap等等)提前拦截


对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃。还有最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。

- 适用场景：数据命中不高，数据相对固定实时性低（通常是数据集较大）
- 维护成本：代码维护复杂, 缓存空间占用少

![](https://images2015.cnblogs.com/blog/37237/201604/37237-20160407211709906-1980347591.png)





### 二、Redis缓存击穿（并发） ###

![](https://images2015.cnblogs.com/blog/97364/201612/97364-20161205122820741-916410826.jpg)

缓存击穿，是指某个极度“热点”数据在某个时间点过期时，恰好在这个时间点对这个 KEY 有大量的并发请求过来，这些请求发现缓存过期一般都会从 DB 加载数据并回设到缓存，但是这个时候大并发的请求可能会瞬间 DB 压垮。




- 对于一些设置了过期时间的 KEY ，如果这些 KEY 可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑这个个问题。
- 缓存被“击穿”的问题，和缓存“雪崩“”的区别在于，前者针对某一 KEY 缓存，后者则是很多 KEY 。
- 缓存被“击穿”的问题，和缓存“穿透“”的区别在于，这个 KEY 是真实存在对应的值的。

解决方法：

- 方案一，使用互斥锁：请求发现缓存不存在后，去查询 DB 前，使用分布式锁，保证有且只有一个线程去查询 DB ，并更新到缓存。流程如下：
	- 1、获取分布式锁，直到成功或超时。如果超时，则抛出异常，返回。如果成功，继续向下执行。
	- 2、再去缓存中。如果存在值，则直接返回；如果不存在，则继续往下执行。 因为，获得到锁，可能已经被“那个”线程去查询过 DB ，并更新到缓存中了。
	- 3、查询 DB ，并更新到缓存中，返回值。

- 方案二，手动过期：缓存上从不设置过期时间，功能上将过期时间存在 KEY 对应的 VALUE 里，如果发现要过期，通过一个后台的异步线程进行缓存的构建，也就是“手动”过期。通过后台的异步线程，保证有且只有一个线程去查询 DB。

这两种方案各有其优缺点。方案一使用互斥锁思路简单、保证一致性，但是代码复杂度增大且存在死锁的风险；方案二性价最佳，用户无需等待，但无法保证缓存一致性

### 三、缓存雪崩 ###


缓存雪崩就是指由于缓存的原因，导致大量请求到达后端数据库，从而导致数据库崩溃，整个系统崩溃，发生灾难。导致这种现象的原因有很多种，上面提到的“缓存并发”，“缓存穿透”，“缓存颠簸”等问题，其实都可能会导致缓存雪崩现象发生。这些问题也可能会被恶意攻击者所利用。还有一种情况，例如某个时间点内，系统预加载的缓存周期性集中失效了，也可能会导致雪崩。为了避免这种周期性失效，可以通过设置不同的过期时间，来错开缓存过期，从而避免缓存集中失效。从应用架构角度，我们可以通过限流、降级、熔断等手段来降低影响，也可以通过多级缓存来避免这种灾难；从整个研发体系流程的角度，应该加强压力测试，尽量模拟真实场景，尽早的暴露问题从而防范。

解决方法：

- 缓存高可用：保证缓存层服务高可用性，避免缓存挂掉导致无法提供服务的情况，从而降低出现缓存雪崩的情况。（假设我们使用 Redis 作为缓存，则可以使用 Redis Sentinel 或 Redis Cluster 实现高可用。）
- 在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。
- 可以通过缓存reload机制，预先去更新缓存，再即将发生大并发访问前手动触发加载缓存
- 不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀
- 做二级缓存，或者双缓存策略。A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期。
- 请求DB限流：通过限制 DB 的每秒请求数，避免把 DB 也打挂了。（如果我们使用 Java ，则可以使用 Guava RateLimiter、Sentinel 实现限流的功能。）
- 服务降级：如果请求被限流，或者请求 DB 超时，我们可以服务降级，提供一些默认的值，或者友情提示，甚至空白的值也行。（如果我们使用 Java ，则可以使用 Hystrix、Sentinel 实现限流的功能。）
- 提前演练：在项目上线前，演练（压测）缓存宕掉后，应用以及后端的负载情况以及可能出现的问题，在此基础上做一些预案设定。

![](https://images2015.cnblogs.com/blog/97364/201612/97364-20161205123238804-1230422379.jpg)


### 四、Redis缓存和DB的一致性问题 ###


（1）产生原因

主要有两种情况，会导致缓存和 DB 的一致性问题：

I、缓存和 DB 的操作，不在一个事务中，可能只有一个操作成功，而另一个操作失败，导致不一致。

- 先更新数据库后更新缓存：更新数据库成功，更新缓存失败 --> 数据不一致

- 先更新数据库后更新缓存：更新缓存成功，更新数据库失败 --> 数据不一致 

- 先更新数据库后更新缓存：更新数据库成功，淘汰缓存失败 --> 数据不一致

- 先更新数据库后更新缓存：淘汰缓存成功，更新数据库失败 --> 查询缓存miss




II、并发的场景下，导致读取老的DB数据，更新到缓存中

(先不讨论更新缓存和更新数据这两个操作是不是在一个事务,或是先不讨论更新缓存和更新数据这两个操作会有失败的可能，也就是假设更新数据库和更新缓存都可以成功的情况)

这四种场景的分歧点有二：第一，是先操作缓存还是先操作数据库？第二，是删除（淘汰）缓存还是更新缓存。

A.更新缓存 VS 淘汰缓存



- 更新缓存的优点：缓存不会增加一次miss,命中率高
- 淘汰缓存的优点：简单

那到底是选择更新缓存还是淘汰缓存呢，主要取决于“更新缓存的复杂度” ————更新缓存的代价很小，此时我们应该更倾向于更新缓存，以保证更高的缓存命中率；更新缓存的代价很大（比如需要通过复杂的计算），此时我们应该更倾向于淘汰缓存。

B.先操作数据库 vs 先操作缓存

（一）先删除缓存，然后再更新数据库

两个并发操作，一个更新操作，另一个是查询操作。更新操作删除缓存后，查询操作没有命中缓存，先把老数据读出来后放到缓存中，然后更新操作更新了数据库。于是，在缓存中的数据还是老的数据，导致缓存中的数据是脏的，而且还一直这样脏下去了。



（二）先更新数据库，然后再删除缓存

- 失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。
- 命中：应用程序从cache中取数据，取到后返回。
- 更新：先把数据存到数据库中，成功后，再让缓存失效。

![](https://coolshell.cn/wp-content/uploads/2016/07/Cache-Aside-Design-Pattern-Flow-Diagram-e1470471723210.png)


![](https://coolshell.cn/wp-content/uploads/2016/07/Updating-Data-using-the-Cache-Aside-Pattern-Flow-Diagram-1-e1470471761402.png)


两个并发操作，一个更新操作，另一个是查询操作。首先，没有了删除cache数据的操作了，而是先更新了数据库中的数据，此时，缓存依然有效，所以，并发的查询操作拿的是没有更新的数据，但是，更新操作马上让缓存的失效了，后续的查询操作再把数据从数据库中拉出来。而不会像先删除缓存，然后再更新数据库的那个逻辑产生的问题，后续的查询操作一直都在取老的数据。

那么，是不是就说“先更新数据库，然后再删除缓存”这种方式就不会有并发问题了？不是的，比如，一个是读操作，但是没有命中缓存，然后就到数据库中取数据，此时来了一个写操作，写完数据库后，让缓存失效，然后，之前的那个读操作再把老的数据放进去，所以，会造成脏数据。

但，这个case理论上会出现，不过，实际上出现的概率可能非常低，因为这个条件需要发生在读缓存时缓存失效，而且并发着有一个写操作。而实际上数据库的写操作会比读操作慢得多，而且还要锁表，而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存，所有的这些条件都具备的概率基本并不大。


（2）解决方案

在开始说解决方案之前，建议先看看如下几篇文章

- [《缓存更新的套路》](https://coolshell.cn/articles/17416.html)
- [《缓存架构设计细节二三事》](https://www.w3cschool.cn/architectroad/architectroad-cache-architecture-design.html)
- [《缓存与数据库一致性优化》](https://www.w3cschool.cn/architectroad/architectroad-consistency-of-cache-with-database.html)


无论哪种方案，最重要的就是解决两个问题：

- 1、将缓存可能存在的并行写，实现串行写。
- 2、实现数据的最终一致性。

（一）先淘汰缓存，再写数据库

因为先淘汰缓存，所以数据的最终一致性是可以得到有效的保证的。为什么呢？先淘汰缓存，即使写数据库发生异常，也就是下次缓存读取时，多读取一次数据库。但是，这种方案当遇到并发的场景下会存在缓存和 DB 的数据不一致的情况，那么需要解决缓存并行写，实现串行写。比较简单的方式，引入分布式锁。

- 在写请求时，先淘汰缓存之前，获取该分布式锁。（写请求时，是否主动更新缓存，根据自己业务的需要，是否有，都没问题。）
- 在读请求时，发现缓存不存在时，先获取分布式锁。

这样，缓存的并行写就成功的变成串行写落。


（二）先写数据库，再更新缓存

按照“先写数据库，再更新缓存”，我们要保证 DB 和缓存的操作，能够在“同一个事务”中，从而实现最终一致性。


基于定时任务来实现



- 首先，写入数据库。
- 然后，在写入数据库所在的事务中，插入一条记录到任务表。该记录会存储需要更新的缓存 KEY 和 VALUE 。
- 【异步】最后，定时任务每秒扫描任务表，更新到缓存中，之后删除该记录。


基于消息队列来实现


- 首先，写入数据库。
- 然后，发送带有缓存 KEY 和 VALUE 的事务消息。此时，需要有支持事务消息特性的消息队列，或者我们自己封装消息队列，支持事务消息。
- 【异步】最后，消费者消费该消息，更新到缓存中。

（这两种方式，可以进一步优化，可以先尝试更新缓存，如果失败，则插入任务表，或者事务消息。）

另外，极端情况下，如果并发写执行时，先更新成功 DB 的，结果后更新缓存，你可能会说上面不是基于定时任务或消息队列来实现异步更新缓存吗，但是如果网络抖动导致插入任务表或者事务消息的顺序不一致就会导致这种情况。那么怎么解决呢？需要做如下三件事情

- 1、在缓存值中，拼接上数据版本号或者时间戳。例如说：value = {value: 原值, version: xxx} 。
- 2、在任务表的记录，或者事务消息中，增加上数据版本号或者时间戳的字段。
3、在定时任务或消息队列执行更新缓存时，先读取缓存，对比版本号或时间戳，大于才进行更新。当然，此处也会有并发问题，所以还是得引入分布式锁或 CAS 操作。


（三）基于数据库的 binlog 日志

![](http://upload-images.jianshu.io/upload_images/1049928-78c959e0e4696330.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

可以看到这种方案对研发人员来说比较轻量，不用关心缓存层面，而且这个方案虽然比较重，但是却容易形成统一的解决方案。




### 五、Redis上踩过的一些坑 ###

(部分内容转载自：[Redis上踩过的一些坑-美团](http://blog.csdn.net/chenleixing/article/details/50530419)、[那些年使用缓存踩过的坑](https://mp.weixin.qq.com/s?__biz=MzI3OTUwMjM4MA%3D%3D&mid=2247483718&idx=1&sn=3324abf6b2a3245e330b35213ee922a5&chksm=eb478a05dc300313355f4e437ec701b58356c4aa19ad36c46c4031216dab3016e016bda8afee))




**案例1：缓存和DB的同步更新不在同一个事务里并且没有重试补偿机制**

场景描述：

为了减少系统间的依赖，不同系统的数据更新往往不放在同一个事务里，采用MQ来进行通信。比如，后台系统CRM更新产品数据到DB，Product系统收到异步消息通知后，更新最新数据到缓存。这是一个最常见的缓存应用场景，我相信很多团队都是这样用的。在这个Case里容易出现的问题在于，如果批处理任务收到消息后服务crash掉了，缓存没有正常更新，就出现了与DB的数据不同步，前端系统一直不能读到最新数据，导致业务异常。




解决方案：


- 1）.失败消息一定要建立一定时间间隔的重试机制
- 2） 系统要有缓存更新的报警机制，方便更新失败或者重试超时后，可以人工介入进行补偿。


**案例2： 同一数据被1个以上的服务执行写操作，其中一个服务的缓存数据没有版本控制**

场景描述：

这也是两个不同服务更新数据过程中很常见的情况，CRM系统更新了某个用户的Profile, 保存更新数据库后，通过MQ通知用户系统更新缓存，由于是异步更新延迟，在缓存更新前，用户系统收到前端的指令，读取了当前缓存里的用户数据，做了修改，并更新到DB中。出现的结果就是数据库里的CRM的更新被错误覆盖。



解决方案：

缓存里的数据有一个标志位可以作为更新数据库数据的依据（Update_time or Version）, 如果缓存里数据时间与数据库时间不能匹配，意味着另外一个服务更新了该数据，那么就先从DB里读取最新数据版本，然后在新版本上提交数据。




**案例3： 并发查询缓存中同一数据，如果缓存没命中，导致DB瞬时被打爆**

场景描述：

做促销活动的时候，存在大量用户的并发访问某一个特定商品，该商品数据缓存失效，或者做了数据更改，但是对应缓存还没有更新，那么所有这些访问将同时直接被作用到DB上。


解决方案：

做一个计数器或者锁（没有特别复杂逻辑的话，可以直接用HashMap），如果发现某个KEY缓存没有命中，那么在计数器+1, 然后访问数据库，拿到结果更新缓存，清理掉计数器中的key。 在这个过程中，如果有第二个线程或者更多的线程需要访问这个KEY时，发现计数器的值>1 或者被加锁, 那么wait, 直到计数器清理掉，当然，这个技术器阈值是可以在配置文件里配置的，不一定是1。



**案例4：缓存没有设置默认值，被攻击，缓存一直保持在被“穿透”状态**

场景描述：

这个情况，和案例3比较类似，都是缓存无法命中，但不一样的地方在于，数据的KEY值是无法控制的，所以没法简单的用计数器和锁来处理, 比方，被人为攻击，制造的大量的无效userID访问。

解决方案：

所有没有在缓存的KEY，全部分配一个默认VALUE “UNKOWN-KEY” ，具体是什么情况下，将默认值分配给没有命中的KEY， 这个可以根据自己的业务系统来定，比方说，可以根据特定的IP段，或者没有命中的总次数等，然后我们就可以决定是否继续访问DB还是直接返回默认值给前端，拒绝本次数据访问。这种做法的核心在于，每次数据访问，都会有缓存结果返回，根据系统的情况来决定是否要进一步访问DB。


**案例5：NULL缓存穿透**

场景描述：

shop_img 缓存穿透 

解决方案：

（mysql select 7k ------> mysql global log ------> 前置redis------> 加了还有 -----> 空数据没缓存  ------> 仍然有问题 ------> 漏了一个地方）


**案例6：redis内存占用飙升**

场景描述：

redis-cluster某个分片内存飙升，明显比其他分片高很多，而且持续增长。并且主从的内存使用量并不一致。

![](http://dl2.iteye.com/upload/attachment/0112/8746/c1763302-3ce3-3aa1-ab06-b79c9a5568f9.jpg)

分析可能原因：


- （1）redis-cluster的bug （这个应该不存在）
- （2）客户端的hash(key)有问题，造成分配不均。（redis使用的是crc16, 不会出现这么不均的情况）
- （3）存在个别大的key-value: 例如一个包含了几百万数据set数据结构（这个有可能）
- （4）主从复制出现了问题。
- （5）其他..................



**案例7：**

场景描述：

周期性出现connect timeout

分析可能的原因：


- (1). 网络原因：比如是否存在跨机房、网络割接等等。
- (2). 慢查询，因为redis是单线程，如果有慢查询的话，会阻塞住之后的操作。 
- (3). value值过大？比如value几十兆，当然这种情况比较少，其实也可以看做是慢查询的一种
- (4). aof重写/rdb fork发生？瞬间会堵一下Redis服务器。
- (5). 其他..................



总结，今天列举的这几个案例，归纳起来，可以总结为以下几点：
1. 保证缓存同步
2. 减少缓存并发
3. 杜绝缓存穿透




### 五、缓存使用心得 ###



1.缓存不是DB

- 主要解决频繁的低IO速率读取
- 大多数场景不做持久化，可随时被淘汰


2.内存很珍贵

- 合理设计需要缓存的数据，避免过大数据(<20K)
- 过期时间必须设置且不要超过1周


3.命中率很重要

- 50%与95%对DB而言，相差10倍请求量




### 附录 ###

- [一篇文读懂缓存在大型分布式系统中的最佳应用](http://dbaplus.cn/news-21-969-1.html)
- [缓存的正确使用方式，你都会了吗？](https://mp.weixin.qq.com/s/wgsB3GU9rpZoV6p9xwX34A)
- [Redis架构之防雪崩设计：网站不宕机背后的兵法](https://mp.weixin.qq.com/s/TBCEwLVAXdsTszRVpXhVug)









