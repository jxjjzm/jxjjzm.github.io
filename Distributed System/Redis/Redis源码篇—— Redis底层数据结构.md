### Redis源码篇—— Redis底层数据结构 ###
***

重点声明：本篇源码针对Redis2.9版本（即Redis3.0开发版），不含3.0之后的新增内容。

### 一、简单动态字符串 ###

Redis没有直接使用C语言传统的字符串表示（以空字符结尾的字符数组，以下简称C字符串），而是自己构建了一种名为简单动态字符串（simple dynamic string,SDS）的抽象类型，并将SDS用作Redis的默认字符串表示。(在Redis里面，C字符串只会作为字符串字面量用在一些无需对字符串值进行修改的地方，比如打印日志；当Redis需要的不仅仅是一个字符串字面量，而是一个可以被修改的字符串值时，Redis就会使用SDS来表示字符串值)

	struct SDS<T> {
	  int len; // 记录buf数组中已使用字节的数量，等于SDS所保存字符串的长度
	  int free; // 记录buf数组中未使用字节的数量
	  char buf[]; // 字节数组，用于保存字符串
	}


#### 1.SDS与C字符串的区别 ####

- 常数复杂度获取字符串长度：通过使用SDS而不是C字符串，Redis将获取字符串长度所需的复杂度从O(N)降低到了O(1),这确保了获取字符串长度的工作不会成为Redis的性能瓶颈。
	- 因为C字符串并不记录自身的长度信息，所以为了获取一个C字符串的长度，程序必须遍历整个字符串，对遇到的每个字符进行计数，直到遇到代表字符串结尾的空字符串为止，这个操作的复杂度为O(N)
	- 对于SDS来说，程序只要访问SDS的len属性，就可以立即知道字符串长度信息。（设置和更新SDS长度的工作是由SDS的API在执行时自动完成的，使用SDS无须进行任何手动修改长度的工作）


- 杜绝缓冲区溢出：除了获取字符串长度的复杂度高之外，C字符串不记录自身长度带来的另一个问题是容易造成缓冲区溢出；与C字符串不同，SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能性：当SDS API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的要求，如果不满足的话，API会自动将SDS的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用SDS既不需要手动修改SDS的空间大小，也不会出现前面所说的缓冲区溢出问题。

- 减少修改字符串时带来的内存重分配次数：
	- 因为C字符串并不记录自身的长度，所以对于一个包含了N个字符串的C字符串来说，这个C字符串的底层实现总是一个N+1个字符串的数组（额外的一个字符空间用于保存空字符）。因为C字符串的C字符串的长度和底层数组的长度之间存在着这种关联性，所以每次增长或者缩短一个C字符串，程序都总要对保存这个C字符串的数组进行一次内存重分配操作:如果程序执行的是增长字符串的操作，那么执行这个操作之前，程序需要先通过内存重分配来扩展底层数组的空间大小——如果忘了这一步就会产生缓冲区溢出；如果程序执行的是缩短字符串的操作，那么在执行这个操作之后，程序需要通过内存重分配来释放字符串不再使用的那部分空间——如果忘了这一步就会产生内存泄漏。
	- 为了避免C字符串的这种缺陷，SDS通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略。
		- 空间预分配：空间预分配用于优化SDS的字符串增长操作：当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所必须要的空间，还会为SDS分配额外的未使用空间。—— 如果对SDS进行修改之后，SDS的长度将小于1MB，那么程序分配和len属性同样大小的未使用空间，这时SDS len属性的值将和free属性的值相同；如果对SDS进行修改之后，SDS的长度将大于等于1MB，那么程序会分配1MB的未使用空间。（通过空间预分配策略，Redis可以减少连续执行字符串增长操作所需的内存重分配次数）
		- 惰性空间释放：当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录起来，并等待将来使用。

- 二进制安全：
	- C字符串中的字符必须符合某种编码（比如ASCII），并且除了字符串的末尾之外，字符串里面不能包含空字符，否则最先被程序读入的空字符将被误认为是字符串结尾，这些限制使得C字符串只能保存文本数据，而不能保存像图片、音频、视频、压缩文件这样的二进制数据。
	- 为了确保Redis可以适用于各种不同的使用场景，SDS的API都是二进制安全的，所有SDS API都会以处理二进制的方式来处理SDS存放在buf数组里的数据，程序不会对其中的数据做任何限制、过滤.....

- 兼容部分C字符串函数：C字符串可以使用所有<string.h>库中的函数，SDS可以使用一部分<string.h>库中的函数。





**重点回顾**：


- Redis 的字符串是动态字符串（SDS），是可以修改的字符串，内部结构实现上类似于 Java 的 ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配。扩容策略：字符串在长度小于 1M 之前，扩容空间采用加倍策略，也就是保留 100% 的冗余空间。当长度超过 1M 之后，为了避免加倍后的冗余空间过大而导致浪费，每次扩容只会多分配 1M 大小的冗余空间。需要注意的是字符串最大长度为 512M。（第一次创建没有冗余，执行append之后开始冗余，因为平时的应用中大多数字符串只有只读的需求，一旦遇到append指令意味着它是需要支持修改的，于是才给分配了冗余空间）
- 比起C字符串。SDS具有以下优点。
	- 常数复杂度获取字符串长度
	- 杜绝缓冲区溢出
	- 减少修改字符串时带来的内存重分配次数
	- 二进制安全
	- 兼容部分C字符串函数


### 二、链表 ###


1.链表节点

每个链表节点使用一个adlist.h/listNode结构来表示：

	typedef struct listNode {
	
	    // 前置节点
	    struct listNode *prev;
	
	    // 后置节点
	    struct listNode *next;
	
	    // 节点的值
	    void *value;
	
	} listNode;

多个listNode可以通过prev和next指针组成双端链表：

![list结构和listNode组成的链表结构 ](https://i.imgur.com/E4gRbsJ.png)


	typedef struct list {
	
	    // 表头节点
	    listNode *head;
	
	    // 表尾节点
	    listNode *tail;
	
	    // 链表所包含的节点数量
	    unsigned long len;
	
	    // 节点值复制函数
	    void *(*dup)(void *ptr);
	
	    // 节点值释放函数
	    void (*free)(void *ptr);
	
	    // 节点值对比函数
	    int (*match)(void *ptr, void *key);
	
	} list;


虽然仅仅使用多个listNode结构就可以组成链表，但使用adlist.h/list来持有链表的话，操作起来会更方便。Redis的链表实现的特性可以总结如下：


- 双端： 链表节点带有 prev 和 next 指针， 获取某个节点的前置节点和后置节点的复杂度都是 O(1)
- 无环： 表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL ， 对链表的访问以 NULL 为终点
- 带表头指针和表尾指针： 通过 list 结构的 head 指针和 tail 指针， 程序获取链表的表头节点和表尾节点的复杂度为 O(1)
- 带链表长度计数器： 程序使用 list 结构的 len 属性来对 list 持有的链表节点进行计数， 程序获取链表中节点数量的复杂度为 O(1)
- 多态： 链表节点使用 void* 指针来保存节点值， 并且可以通过 list 结构的 dup 、 free 、 match 三个属性为节点值设置类型特定函数， 所以链表可以用于保存各种不同类型的值

**重点回顾**：

- 链表被广泛用于实现Redis的各种功能。比如列表键、发布与订阅、慢查询、监视器等。
- 每个链表节点由一个listNode结构来表示，每个节点都有一个指向前置节点和后置节点的指针，所以Redis的链表实现是双端链表。
- 每个链表使用一个list结构来表示，这个结构带有表头节点指针、表尾节点指针、以及链表长度等信息。
- 因为链表表头节点的前置节点和表尾节点的后置节点都指向Null，所以Redis的链表实现是无环链表。
- 通过为链表设置不同的类型特定函数，Redis的链表可以用于保存各种不同类型的值。




### 三、字典 ###

#### （一）、字典的实现（数据结构） ####

1.哈希表节点

哈希表节点使用dictEntry结构表示，每个dictEntry结构都保存着一个键值对：

- key属性保存着键值对中的键，而v属性则保存着键值对中的值，其中键值对的值可以是一个指针，或者是一个uint4_t整数，又或者是一个int4_t整数。
- next属性是指向另一个哈希表节点的指针



		/* 哈希表节点 */
		typedef struct dictEntry {
		void *key; /* 键名 */
		union {
		void *val;
		uint64_t u64;
		int64_t s64;
		double d;
		} v; /* 值 */
		struct dictEntry *next; /* 指向下一个节点, 形成链表*/
		} dictEntry;



2.哈希表

Redis字典所使用的哈希表由dict.h/dictht结构定义：：

- table属性是一个数组，数组中的每个元素都是一个指向dict.h/dictEntry结构的指针
- size属性记录了哈希表的大小，也即是table数组的大小
- used属性则记录了哈希表目前已有节点（键值对）的数量
- sizemask属性的值总是等于size-1,这个属性和哈希值一起决定一个键应该被放到table数组的哪个索引上面。

	    /* 哈希表结构 */
    	typedef struct dictht {
    	dictEntry **table; /* 哈希表节点数组 */
    	unsigned long size; /* 哈希表大小 */
    	unsigned long sizemask; /* 哈希表大小掩码，用于计算哈希表的索引值，大小总是size - 1 */
    	unsigned long used; /* 哈希表已经使用的节点数量 */
    	} dictht;


![](https://i.imgur.com/Ki82mZN.png)


3.字典

Redis中的字典由dict.h/dict结构表示：

- type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不用的类型特定函数。
- privdata属性则保存了需要传给那些特定函数的可选参数。
- ht属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表，一般情况下，字典只使用ht[0]哈希表，ht[1]哈希表只会在对ht[0]哈希表进行rehash时使用。
- rehashidx记录了rehash目前的进度，如果目前没有在进行rehash,那么它的值为-1.



	    /* 字典结构 每个字典有两个哈希表，实现渐进式哈希时需要用在将旧表rehash到新表 */
    	typedef struct dict {
    	dictType *type; /* 类型特定函数 */
    	void *privdata; /* 保存类型特定函数需要使用的参数 */
    	dictht ht[2]; /* 保存的两个哈希表，ht[0]是真正使用的，ht[1]会在rehash时使用 */
    	long rehashidx; /* rehashing not in progress if rehashidx == -1 rehash进度，如果不等于-1，说明还在进行rehash */
    	unsigned long iterators; /* number of iterators currently running 正在运行中的遍历器数量 */
    	} dict;

其中，dictType 结构体定义如下

	/* 保存一连串操作特定类型键值对的函数 */
	typedef struct dictType {
	    uint64_t (*hashFunction)(const void *key); /* 哈希函数 */
	    void *(*keyDup)(void *privdata, const void *key); /* 复制键函数 */
	    void *(*valDup)(void *privdata, const void *obj); /* 复制值函数 */
	    int (*keyCompare)(void *privdata, const void *key1, const void *key2); /* 比较键函数 */
	    void (*keyDestructor)(void *privdata, void *key); /* 销毁键函数 */
	    void (*valDestructor)(void *privdata, void *obj); /* 销毁值函数 */
	} dictType;


![](https://i.imgur.com/lM1sEEd.png)


#### （二）、哈希算法 ####

当要将一个新的键值对添加到字典里面时，程序需要先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。（当发生Hash冲突时，Redis的哈希表使用链地址法来解决键冲突（因为dictEntry节点组成的链表没有指向链表表尾的指针，所以为了速度考虑，程序总是将新节点添加到链表的表头位置，排在其他已有节点的前面））


#### （三）、rehash ####

Redis 哈希表不仅支持扩容，还支持缩容，这些工作可以通过执行rehash(重新散列)操作来完成，Redis对字典的哈希表执行rehash的步骤如下：

- 为字典的ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作以及ht[0]当前包含的键值对数量（也即是ht[0].used属性的值）:
	- 如果执行的是扩容操作，那么ht[1]的大小为第一个大于等于ht[0].used*2的2^n(2的n次方幂)；
	- 如果执行的是缩容操作，那么ht[1]的大小为第一个大于等于ht[0].used的2^n(2的n次方幂)
- 将保存在ht[0]中的所有键值对rehash到ht[1]上面：rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上。
- 当ht[0]包含的所有键值对都迁移到了ht[1]之后（ht[0]变为空表），释放ht[0],将ht[1]数值为ht[0]，并在ht[1]新创建一个空白哈希表，为下一次rehash做准备。


**Redis扩容条件** —— 当以下条件中的任意一个被满足时，程序会自动开始对哈希表执行扩容操作：


- 服务器目前没有执行BGSAVE、BGREWRITEAOF命令，并且哈希表的负载因子大于等于1.（其中，负载因子=哈希表已保存节点数量/哈希表大小）
- 服务器目前正在执行行BGSAVE、BGREWRITEAOF命令，并且哈希表的负载因子大于等于5.

**Redis缩容条件** —— 当哈希表的负载因子小于0.1时，程序自动开始对哈希表执行缩容操作。


#### （三）、渐进式rehash ####

为了避免rehash对服务器性能造成影响，服务器不是一次性将ht[0]里面的所有键值对全部rehash到ht[1],而是分多次、渐进式地将ht[0]里面的键值对慢慢地rehash到ht[1]。以下是哈希表渐进式rehash的详细步骤：

- 为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。
- 在字典中维持一个索引计数器变量rehashidx,并将它的值设置为0，标识rehash工作正式开始。
- 在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1],当rehash工作完成之后，程序将rehashidx属性的值增一。
- 随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash至ht[1],这时程序将rehashidx属性的值设为-1，标识rehash操作已完成。

渐进式rehash的好处在于它分而治之的方式，将rehash键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上，从而避免了集中式rehash而带来的庞大计算量。（说明：因为在进行渐进式rehash的过程中，字典会同时使用ht[0]和ht[1]两个哈希表，所以在渐进式rehash进行期间，字典的删除、查找、更新操作会在两个哈希表上进行，但是新添加到字典的键值对一律会被保存到ht[1]里面，而ht[0]则不再进行任何添加操作，这一措施保证了ht[0]包含的键值对数量会只减不增，并随着rehash操作的执行而最终变成空表）


**重点回顾**：

- 字典被广泛用于实现Redis的各种功能，其中包括数据库和哈希键。
- Redis中的字典使用哈希表作为底层实现，每个字典带有两个哈希表，一个平时使用，另一个仅在进行rehash时使用。
- 当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用MurmurHash2算法来计算键的哈希值。
- 哈希表使用链地址法来解决键冲突，被分配到同一个索引上的多个键值对会连接成一个单向链表。
- 在对哈希表进行扩展或者收缩操作时，程序需要将现有哈希表包含的所有键值对rehash到新哈希表里面，并且这个rehash过程并不是一次性地完成的，而是渐进式地完成的。


### 四、跳跃表 ###


#### 1.跳跃表节点 ####

跳跃表是一种有序的数据结构，他通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的；
跳跃表支持平均O（logN），最坏O（N）复杂度的节点查找，还可以通过顺序性操作来批量处理节点。性能上和平衡树媲美，因为实现简单，常用来代替平衡树。在redis中，只在两个地方使用了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构。


跳跃表节点的实现由redis.h/zskiplistNode结构定义：

    typedef struct zskiplistNode {
	    robj *obj;  //保存的成员对象
	    double score;   //分值
	    struct zskiplistNode *backward; //后退指针
	    struct zskiplistLevel {
	    struct zskiplistNode *forward;  //前进指针
	    unsigned int span;  //跨度
	    } level[];  //层，柔型数组
    } zskiplistNode;
    

- 层 ： 跳跃表节点的Level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度，一般来说，层的数量越多，访问其他节点的速度就越快。（每次创建一个新跳跃表节点的时候，程序都根据幂次定律随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是层的“高度”）
- 前进指针： 每个层都有一个指向表尾方向的前进指针，用于从表头向表尾方向访问节点。
- 跨度：层的跨度用于记录两个节点之间的距离（初看上去很容易认为跨度和遍历操作有关，但实际并不是这样，遍历操作只使用前进指针就可以完成了，跨度实际上是用来计算排位(rank)的：在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位）：
	- 两个节点之间的跨度越大，他么相距得就越远。
	- 指向NULL的所有前进指针的跨度都为0，因为它们没有连向任何节点。
- 后退指针： 用于从表尾向表头方向访问节点。
- 分值：节点的分支(score)是一个double类型的浮点数，跳跃表中的所有节点都按分支从小到大来排序。
- 成员：节点的成员变量是一个指针，它指向一个字符串对象，而字符串对象则保存着一个SDS值。（在同一个跳跃表中，各个节点）



#### 2.跳跃表 ####

仅靠多个跳跃表节点就可以组成一个跳跃表，但通过一个zskiplist结构来持有这些节点，程序可以更方便地对整个跳跃表进行处理。

    typedef struct zskiplist {
	    struct zskiplistNode *header, *tail;//header指向跳跃表的表头节点，tail指向跳跃表的表尾节点
	    unsigned long length;   //跳跃表的长度或跳跃表节点数量计数器
	    int level;  //跳跃表中节点的最大层数（表头节点的层高并不计算在内）
    } zskiplist;



![](https://i.imgur.com/bNHB0YG.png)


**重点回顾**：

- 跳跃表是有序集合的底层实现之一。
- Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息（比如表头节点、表尾节点、长度），而zskiplistNode则用于表示跳跃表节点。
- 每个跳跃表节点的层高都是1至32之间的随机数。
- 在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的。
- 跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序。



### 五、整数集合 ###

整数集合(intset)是Redis用于保存整数值的集合抽象数据结构，它可以保存类型为int16_t、int32_t 或者 int64_t的整数值，并且保证集合中不会出现重复元素。每个intset.h/intset结构表示一个整数集合：


    typedef struct intset {
	    uint32_t encoding;  //编码方式，决定整数位宽是 16 位、32 位还是 64 位
	    uint32_t length;  //集合包含的元素数量
	    int8_t contents[];//保存元素的数组
    } intset;



- contents数组是整数集合的底层实现：整数集合的每个元素都是contents数组的一个数组项(item),各个项在数组中按值的大小从小到大有序地排列，并且数组中不包含任何重复项。
- length属性记录了整数集合包含的元素数量，也即是contents数组的长度。


#### 1.升级 ####

整数集合中可以存储int16_t、int32_t、int64_t这三种类型的整数，但在任一时刻，集合中所有元素的类型都是统一的。 
如果当前集合存储的元素是int16_t类型，当需要存入一个int32_t类型的整数时，Redis会分配一片新的内存空间，将每个元素的类型提升为int32_t，再将所有元素迁移至新数组中。 

- 整数集合的升级策略有两个好处，一个是提升整数集合的灵活性，另一个就是尽可能地节约内存。
- 整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。


**重点回顾**：

- 整数集合是集合键的底层实现之一。
- 整数集合的底层实现为数组，这个数组以有序、无重复的方式保存集合元素，在有需要时，程序会根据新添加元素的类型，改变这个数组的类型。
- 升级操作为整数集合带来了操作上的灵活性，并且尽可能的节约了内存。
- 整数集合只支持升级操作，不支持降级操作。


### 六、压缩列表 ###

压缩列表（ziplist）是zset和hash键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现；另外，当一个哈希键只包含少量键值对，并且每个键值对的键和值要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做哈希键的底层实现。

压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存快组成的顺序型数据结构。一个压缩列表可以包含任意多个节点(entry),每个节点保存一个字节数组或者一个整数值。


	struct ziplist<T> {
	    int32 zlbytes; // 整个压缩列表占用字节数
	    int32 zltail_offset; // 最后一个元素距离压缩列表起始位置的偏移量，用于快速定位到最后一个节点
	    int16 zllength; // 元素个数
	    T[] entries; // 元素内容列表，挨个挨个紧凑存储
	    int8 zlend; // 标志压缩列表的结束，值恒为 0xFF
	}


![](https://i.imgur.com/U8nzUKN.png)

- zlbytes ：记录整个压缩列表占用的内存字节数，在对压缩列表进行内存重分配或者计算zlend的位置时使用。
- zltail_offset ：记录压缩列表表尾节点距离压缩列表的其实地址有多少字节，通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址。
- zllength ：记录了压缩列表包含的节点数量
- zllength ：压缩列表包含的各个节点，节点的长度由节点保存的内容决定
- zlend ：特殊值0xFF（十进制255），用于标记压缩列表的末端



entry 块随着容纳的元素类型不同，也会有不一样的结构。


	struct entry {
	    int<var> prevlen; // 前一个 entry 的字节长度
	    int<var> encoding; // 元素类型编码
	    optional byte[] content; // 元素内容
	}


![](https://i.imgur.com/DV46xTT.png)

- prevlen ：节点的 previous_entry_length 属性以字节为单位， 记录了压缩列表中前一个节点的长度 ，previous_entry_length属性的长度可以是1字节或者5字节（如果前一节点的长度小于254字节，那么previous_entry_length属性的长度为1字节：前一节点的长度就保存在这一个字节里面。如果前一字节的长度大于等于254字节，那么previous_entry_length属性的长度为5字节 —— 其中属性的第一字节会被设置为0XFE（十进制254），而之后的四个字节则用于保存前一节点的长度）
- encoding ：节点的 encoding 属性记录了节点的 content 属性所保存数据的类型以及长度
- content ：节点的 content 属性负责保存节点的值， 节点值可以是一个字节数组或者整数， 值的类型和长度由节点的 encoding 属性决定。 

#### 1.增加元素 ####


因为 ziplist 都是紧凑存储，没有冗余空间 (对比一下 Redis 的字符串结构)。意味着插入一个新的元素就需要调用 realloc 扩展内存。取决于内存分配器算法和当前的 ziplist 内存大小，realloc 可能会重新分配新的内存空间，并将之前的内容一次性拷贝到新的地址，也可能在原有的地址上进行扩展，这时就不需要进行旧内容的内存拷贝。如果 ziplist 占据内存太大，重新分配内存和拷贝内存就会有很大的消耗。所以 ziplist 不适合存储大型字符串，存储的元素也不宜过多。

#### 2.连锁（级联）更新 ####

前面提到每个 entry 都会有一个 prevlen 字段存储前一个 entry 的长度。如果内容小于 254 字节，prevlen 用 1 字节存储，否则就是 5 字节。这意味着如果某个 entry 经过了修改操作从 253 字节变成了 254 字节，那么它的下一个 entry 的 prevlen 字段就要更新，从 1 个字节扩展到 5 个字节；如果这个 entry 的长度本来也是 253 字节，那么后面 entry 的 prevlen 字段还得继续更新。 ziplist 里面每个 entry 恰好都存储了 253 字节的内容，那么第一个 entry 内容的修改就会导致后续所有 entry 的级联更新，这就是一个比较耗费计算资源的操作。（同理，删除中间的某个节点也可能会导致级联更新）

虽然，添加新节点到压缩列表或者从压缩列表中删除节点，可能会引发连锁更新操作，但这种操作出现的几率并不高。


**重点回顾：**

- 压缩列表是一种为节约内存而开发的顺序型数据结构。
- 压缩列表被用作列表键和哈希键的底层实现之一。
- 压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值。
- 添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引发连锁更新操作，但这种操作出现的几率并不高。


### 七、对象 ###

前面我们陆陆续续介绍了Redis用到的所有主要数据结构，比如简单字符串SDS、双端链表、字典、压缩列表、整数集合等等。然而，Redis并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建一个对象系统。

Redis中的每个对象都是由一个redisObject结构表示：

	struct RedisObject {
	    int4 type; // 4bits 数据类型
	    int4 encoding; // 4bits 编码方式
	    int24 lru; // 24bits
	    int32 refcount; // 4bytes
	    void *ptr; // 8bytes，64-bit system
	} robj;

其中，

- type（4bit）属性记录了对象的类型（REDIS_STRING、REDIS_LIST、REDIS_HASH、REDIS_SET、REDIS_ZSET），Type命令的实现方式也与此类似，当我们对一个数据库键执行TYPE命令时，命令返回的结果为数据库键对应的值对象的类型，而不是键对象的类型。

- encoding(4bit)属性记录了对象使用的编码类型（也即是说这个对象使用了什么数据结构作为对象的底层实现），使用OBJECT ENCODING命令可以查看一个数据库键的值对象的编码
	- REDIS_ENCODING_INT ： long类型整数
	- REDIS_ENCODING_EMBSTR ： embstr编码的简单动态字符串
	- REDIS_ENCODING_RAW ： raw编码的简单动态字符串
	- REDIS_ENCODING_HT ：字典
	- REDIS_ENCODING_LINKEDLIST ： 双端链表
	- REDIS_ENCODING_ZIPLIST ： 压缩列表
	- REDIS_ENCODING_INTSET ：整数集合
	- REDIS_ENCODING_SKIPLIST :跳跃表

（每种类型的对象都至少使用了两种不同的编码）

- lru（24bit）: 最近最后一次被命令访问的时间 或者 最近最少使用的数据。
- refcount: 对象的引用计数，当引用计数为零时，对象就会被销毁，内存被回收。
- ptr: 指向底层数据结构用于保存数据的指针



#### 1.字符串对象 ####



字符串对象的编码可以是int、raw或者embstr

- 如果一个字符串对象保存的是整数值，并且这个整数值可以用long类型来表示，那么字符串对象会将整数值保存在字符串对象结构的ptr里面（将void*转换成long）,并将字符串对象的编码设置为int
- 如果字符串对象保存的是一个字符串值，并且这个字符串值的长度大于32字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为raw.
- 如果字符串对象保存的是一个字符串值，并且这个字符串值的长度小于等于32字节，那么字符串对象将使用embstr编码的方式来保存这个字符串值。



![](https://i.imgur.com/MSYanbA.png)

embstr编码是专门用于保存短字符串的一种优化编码方式，这种编码和raw编码一样，都使用redisObject结构和SDS结构来表示字符串对象，但raw编码会调用两次内存分配函数来分别创建redisObject结构和SDS结构，而embstr编码则通过调用一次内存分配函数来分配一块连续的空间，空间中依次包含redisObject和SDS两个结构

- embstr 存储形式是这样一种存储形式，它将 RedisObject 对象头和 SDS 对象连续存在一起，使用 malloc 方法一次分配。
- raw 存储形式不一样，它需要两次 malloc，两个对象头在内存地址上一般是不连续的。

使用embstr编码的字符串对象来保存短字符串值有以下好处：

- embstr编码将创建字符串对象所需的内存分配次数从raw编码的两次降低为依次；
- 释放embstr编码的字符串对象只需要调用一次内存释放函数，而释放raw编码的字符串对象需要调用两次内存释放函数；
- 因为embstr编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比起raw编码的字符串对象能够更好地利用缓存带来的优势。

**编码转换**：

int编码的字符串对象和embstr编码的字符串对象在条件满足的情况下，会被转换为raw的字符串对象

- 对于int编码的字符串对象来说，如果我们向对象执行了一些命令，使得这个对象保存的不再是整数值，而是一个字符串值，那么字符串对象的编码将从int变为raw.
- 因为Redis没有为embstr编码的字符串边写任何相应的修改程序（只有int编码的字符串对象和raw编码的字符串对象有这些程序），所以embstr编码的字符串实际上是只读的。当我们对embstr编码的字符串对象执行任何修改命令时，程序会先将对象的编码从embstr转换成raw,然后再执行修改命令。因为这个原因，embstr编码的字符串对象在执行修改命令之后，总会变成一个raw编码的字符串对象。

详细可以参考：[源码 1：丝分缕析 —— 探索「字符串」内部结构](https://juejin.im/book/5afc2e5f6fb9a07a9b362527/section/5b5af9d96fb9a04f83465ada)





#### 2.列表对象 ####

列表对象的编码可以是ziplist或者linkedlist,当列表对象可以同时满足以下两个条件时，列表对象使用ziplist编码：


- 列表对象保存的所有字符串元素的长度都小于64字节；
- 列表对象保存的元素数量小于512个；不能满足这两个条件的列表对象需要使用linkedlist编码。

（注意：以上两个条件的上限值是可以修改的，具体请看配置文件中关于list-max-ziplist-value选项和list-max-ziplist-entries选项的说明）

#### 3.哈希对象 ####

哈希对象的编码可以是ziplist 或者hashtable。
 

- ziplist编码的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值的压缩列表节点推入到压缩列表表尾，因此：
	- 保存了同一键值对的两个节点总是紧挨在一起，保存键的节点在前，保存值的节点在后；
	- 先添加到哈希对象中的键值对会被放在压缩列表的表头方向，而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向。
 


- hashtable编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都使用一个字典键值对来保存：
	- 字典的每个键都是一个字符串对象，对象中保存了键值对的键；
	- 字典的每个值都是一个字符串对象，对象中保存了键值对的值。
 
 
当哈希对象同时满足以下两个条件时，哈希对象使用ziplist编码：


- 哈希对象保存的所有键值对的键和值的字符串长度都小于64字节；
- 哈希对象保存的键值对数量小于512个；不能满足这两个条件的哈希对象需要使用hashtable编码。

（注意：以上两个条件的上限值是可以修改的，具体请看配置文件中关于hash-max-ziplist-value选项和hash-max-ziplist-entries选项的说明）

#### 3.集合对象 ####

集合对象的编码可以时inset或者hashtable。



- inset编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里面。
- hashtable编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部设置为NULL。


当集合对象可以同时满足以下两个条件时，对象使用intset编码：


- 集合对象保存的所有元素都是整数值；
- 集合对象保存的元素数量不超过512个。

不能满足这连个条件的集合对象需要使用hashtable编码。

（注意：以上第二个条件的上限值是可以修改的，具体请看配置文件中关于set-max-intset-entries选项的说明）

#### 4.有序集合对象 ####

有序集合的编码可以时ziplist或者skiplist。



- ziplist编码的压缩列表对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员（member），而第二个元素则保存元素的分值（score）。压缩列表内的集合元素按分值从小到大进行排序，分值较小的元素被放置在靠近表头的方向，而分值较大的元素则被放置在靠近表尾的方向。
- skiplist编码的有序集合对象使用zset结构作为底层实现，一个zset结构用时包含一个字典和一个跳跃表

		typedef struct zset{
			zskiplist *zsl;
			dict *dict;
		}zset;

在理论上有序集合可以单独使用字典或者跳跃表的其中一种数据结构来实现，但无论单独使用字典还是跳跃表，在性能上对比起同时使用字典和跳跃表都会有所降低。zset结构中的zsl跳跃表按分值从小到大保存了所有集合元素，每个跳跃表节点都保存了一个集合元素，通过跳跃表程序可以对有序集合进行范围型操作；zset结构中的dict字典为有序集合创建了一个从成员到分值的映射，字典中的每个键值对都保存了一个集合元素，通过这个字典，程序可以用O(1)复杂度查找给定成员的分值。为了让有序集合的查找和范围型操作都尽可能快地被执行，Redis选择了同时使用字典和跳跃表两种数据结构来实现有序集合。


 
当有序集合对象可以同时满足以下两个条件时，对象使用ziplist编码：


- 有序集合保存的元素数量小于128个；
- 有序集合保存的所有元素成员的长度都小于64字节；

不能满足以上两个条件的有序结合对象将使用skiplist编码。

（注意：以上两个条件的上限值是可以修改的，具体请看配置文件中关于zset-max-ziplist-value选项和zset-max-ziplist-entries选项的说明）

#### 5.类型检查与命令多态 ####

I、类型检查

Redis中用于操作键的命令基本上可以分为两种类型：其中一种命令可以对任何类型的键进行执行，比如说DEL命令、EXPIRE命令、RENAME命令、TYPE命令、OBJECT命令等，而另一种命令智能对特定类型的键执行。为了确保只有指定类型的键可以执行某些特定的命令，在执行一个类型特定的命令之前，Redis会先检查输入键的类型是否正确，然后再决定是否执行给定的命令。类型特定命令所进行的类型检查是通过redisObject结构的type属性来实现的：


- 在执行一个类型特定命令之前，服务器会先检查输入数据库键的值对象是否为执行命令所需的类型，如果是的话，服务器就对键执行指定过的命令；
- 否则，服务器将拒绝执行命令，并向客户端返回一个类型错误。

II、命令多态

Redis除了会根据值对象的类型来判断键是否能够执行指定命令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令。DEL、EXPIRE等命令和LLEN等命令的区别在于，前者是基于类型的多态----一个命令可以同时用于处理多种不同类型的键，而后者是基于编码的多态---一个命令可以同时用于处理多种不同编码。



#### 6.内存回收 ####

因为C语言并不具备自动内存回收功能，所以Redis在自己的对象系统中构建了一个引用计数（reference counting）技术实现的内存回收机制，通过这一机制，程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。

对象的引用计数信息会随着对象的使用状态而不断变化：


- 在创建一个新对象时，引用计数的值会被初始化为1；
- 当对象被一个新程序使用时，它的引用计数值会被增1；
- 当对象不再被一个程序使用时，它的引用计数会被减1；
- 当对象的引用计数值变为0时，对象所占用的内存会被释放。


#### 7.对象共享 ####

除了用于实现引用计数内存回收机制之外，对象的引用计数属性还带有对象共享的作用。在Redis中，让多个键共享同一个值对象需要执行以下两个步骤：

- 将数据库键的值指针指向一个现有的值对象；
- 将被共享的值对象的引用计数增一。


Redis会在初始化服务器时，创建一万个字符串对象，这些对象包含了从0到9999的所有整数值，当服务器需要用到值为0到9999的字符串对象时，服务器就会使用这些共享对象，而不是新创建对象。


#### 8.对象的空转时长 ####

除了前面介绍过的type、encoding、ptr和refcount四个属性之外，redisobject结构包含的最后一个属性为lru属性，该属性记录了对象最后一次被命令程序访问的时间。OBJECT IDLETIME命令可以打印出给定键的空转时长，这一空转时长就是通过将当前时间减去键的值对象的lru时间计算得出的。




**重点回顾**：


- Redis数据库中的每个键值对的键和值都是一个对象。
- Redis共有字符串、列表、哈希、集合、有序集合五种类型的对象，没中类型的对象至少都有两种或者以上的编码方式，不同的编码可以在不同的使用场景上优化对象的使用效率。
- 服务器在执行某些命令之前，会先检查给定键的类型能否执行指定的命令，而检查一个键的类型就是检查键的值对象的类型。
- Redis的对象系统带有引用计数实现的内存回收机制，当一个对象不再被使用时，该对象所占用的内存就会被自动释放。
- Redis会共享值为0到9999的字符串对象。
- 对象会记录自己的最后一次被访问的时间，这个时间可以用于计算对象的空转时间。



### 七、补充内容 ###


#### 1.位图 ####

Redis提供了SETBIT、GETBIT、BITCOUNT、BITOP四个命令用于处理二进制位数组（bit array,又称“为数组”、“位图”）。

- SETBIT命令用于为位数组指定偏移量上的二进制位设置值，位数组的偏移量从0开始计数，而二进制位的值则可以是0或者1
- GETBIT命令则用于获取位数组指定偏移量上的二进制位的值
- BITCOUNT命令用于统计位数组里面，值为1的二进制位的数量
- BITOP命令既可以对多个位数组进行按位与(and)、或(or)、异或（xor）运算


位数组不是特殊的数据结构，它的内容其实就是普通的字符串，也就是 byte 数组。Redis使用字符串对象来表示位数组，因为字符串对象使用的SDS数据结构是二进制安全的，所以程序可以直接使用SDS结构来保存位数组，并使用SDS结构的操作函数来处理位数组。

位图在实际开发可能用到的并不是很多，主要的使用场景：用户签到、统计活跃用户（月活）、用户在线状态......



#### 2.HyperLogLog ####

Redis 在 2.8.9 版本添加了 HyperLogLog 结构。Redis HyperLogLog 是用来做基数统计的算法,HyperLogLog 可以接受多个元素作为输入，并给出输入元素的基数估算值.

- 基数：集合中不同元素的数量。比如 {'A', 'B', 'C', 'B', 'A'} 的基数就是 3 。
- 估算值：算法给出的基数并不是精确的，可能会比实际稍微多一些或者稍微少一些，但会控制在合理的范围之内。

HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。(在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。)

（1）

命令：PFADD key element [element ...]

时间复杂度：O(1)

命令描述：将除了第一个参数以外的参数存储到以第一个参数为变量名的HyperLogLog结构中。这个命令的一个副作用是它可能会更改这个HyperLogLog的内部来反映在每添加一个唯一的对象时估计的基数(集合的基数)。如果一个HyperLogLog的估计的近似基数在执行命令过程中发了变化， PFADD返回1，否则返回0，如果指定的key不存在，这个命令会自动创建一个空的HyperLogLog结构（指定长度和编码的字符串）。如果在调用该命令时仅提供变量名而不指定元素也是可以的，如果这个变量名存在，则不会有任何操作，如果不存在，则会创建一个数据结构。

返回值：如果 HyperLogLog 的内部被修改了,那么返回 1,否则返回 0 。

 

（2）

命令：PFCOUNT key [key ...]

命令描述：当参数为一个key时,返回存储在HyperLogLog结构体的该变量的近似基数，如果该变量不存在,则返回0。当参数为多个key时，返回这些HyperLogLog并集的近似基数，这个值是将所给定的所有key的HyperLoglog结构合并到一个临时的HyperLogLog结构中计算而得到的。HyperLogLog可以使用固定且很少的内存（每个HyperLogLog结构需要12K字节再加上key本身的几个字节）来存储集合的唯一元素。返回的可见集合基数并不是精确值， 而是一个带有 0.81% 标准错误（standard error）的近似值。

返回值：PFADD添加的唯一元素的近似数量。

 

（3）

命令：PFMERGE destkey sourcekey [sourcekey ...]

命令描述：将多个 HyperLogLog 合并（merge）为一个 HyperLogLog ， 合并后的 HyperLogLog 的基数接近于所有输入 HyperLogLog 的可见集合（observed set）的并集。合并得出的 HyperLogLog 会被储存在目标变量（第一个参数）里面， 如果该键并不存在， 那么命令在执行之前， 会先为该键创建一个空的。

返回值：这个命令只会返回 OK。


使用场景： 统计UV....


进一步了解HyperLogLog请参考：

- [四两拨千斤 —— HyperLogLog](https://juejin.im/book/5afc2e5f6fb9a07a9b362527/section/5b336548e51d4558a426ff56)
- [见缝插针 —— 探索 HyperLogLog 内部](https://juejin.im/book/5afc2e5f6fb9a07a9b362527/section/5b88cb0651882542b526debb)





#### 3.GeoHash ####

Redis 在 3.2 版本以后增加了地理位置 GEO 模块，意味着我们可以使用 Redis 来实现摩拜单车「附近的 Mobike」、美团和饿了么「附近的餐馆」这样的功能了。这个功能可以将用户给定的地理位置信息储存起来，并对这些信息进行操作将指定的地理空间项目（纬度，经度，名称）添加到指定的键以便于随后的各种检索。

Redis GEO实现主要包含了以下两项技术：

- 使用geohash保存地理位置的坐标。
- 使用有序集合（zset）保存地理位置的集合。

Redis的GEO指令基本使用：

Redis 提供的 Geo 指令只有 6 个，读者们瞬间就可以掌握。在使用 Redis 进行 Geo 查询时，我们要时刻想到它的内部结构实际上只是一个 zset(skiplist)，这意味着我们可以使用 zset 相关的指令来操作 geo 数据。



- geoadd 用来增加地理位置的坐标，可以批量添加地理位置，其格式为: GEOADD key longitude latitude member [longitude latitude member ...]
- geopos 可以获取地理位置的坐标，可以批量获取多个地理位置的坐标，命令格式为：GEOPOS key member [member ...]
- geodist 用来获取两个地理位置的距离（单位可以指定为以下四种类型：m、km、mi、ft），命令格式为：
- georadius 可以根据给定地理位置坐标获取指定范围内的地理位置集合。命令格式为：GEORADIUS key longitude latitude radius [m|km|ft|mi] [WITHCOORD] [WITHDIST] [ASC|DESC] [WITHHASH] [COUNT count]
- georadiusbymember  可以根据给定地理位置获取指定范围内的地理位置集合。georadius命令传递的是坐标，georadiusbymember传递的是地理位置。georadius更为灵活，可以获取任何坐标点范围内的地理位置。但是大多数时候，只是想获取某个地理位置附近的其他地理位置，使用georadiusbymember则更为方便。georadiusbymember命令格式为（命令可选参数与georadius含义一样）：georadiusbymember key member radius [m|km|ft|mi] [WITHCOORD] [WITHDIST] [ASC|DESC] [WITHHASH] [COUNT count]
- geohash 可以获取元素的经纬度编码字符串

了解GeoHash原理请参考：[近水楼台 —— GeoHash](https://juejin.im/book/5afc2e5f6fb9a07a9b362527/section/5b3b2e106fb9a04fcf59acb8)


附：


- [Redis官网](https://redis.io/)
- [Redis中文官方网站](http://www.redis.cn/)
- [Redis 3.2.8源码剖析和注释系列文章地址归总](https://blog.csdn.net/men_wen/article/details/75668345)





































