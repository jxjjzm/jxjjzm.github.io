### Redis源码篇—— Redis底层数据结构 ###
***


首先我们来回顾下上文提到的Redis对象头结构体，所有的 Redis 对象都有下面的这个结构头：

	struct RedisObject {
	    int4 type; // 4bits 数据类型
	    int4 encoding; // 4bits 编码方式
	    int24 lru; // 24bits
	    int32 refcount; // 4bytes
	    void *ptr; // 8bytes，64-bit system
	} robj;


![](http://www.biaodianfu.com/wp-content/uploads/2014/01/redisObject.jpg)

不同的对象具有不同的类型 type(4bit)，同一个类型的 type 会有不同的存储形式 encoding(4bit)，为了记录对象的 LRU 信息，使用了 24 个 bit 来记录 LRU 信息。每个对象都有个引用计数，当引用计数为零时，对象就会被销毁，内存被回收。ptr 指针将指向对象内容 (body) 的具体存储位置......


### 一、简单动态字符串 ###

Redis没有直接使用C语言传统的字符串表示（以空字符结尾的字符数组，以下简称C字符串），而是自己构建了一种名为简单动态字符串（simple dynamic string,SDS）的抽象类型，并将SDS用作Redis的默认字符串表示。(在Redis里面，C字符串只会作为字符串字面量用在一些无需对字符串值进行修改的地方，比如打印日志；当Redis需要的不仅仅是一个字符串字面量，而是一个可以被修改的字符串值时，Redis就会使用SDS来表示字符串值)

	struct SDS<T> {
	  int len; // 记录buf数组中已使用字节的数量，等于SDS所保存字符串的长度
	  int free; // 记录buf数组中未使用字节的数量
	  char buf[]; // 字节数组，用于保存字符串
	}


#### 1.SDS与C字符串的区别 ####

- 常数复杂度获取字符串长度：通过使用SDS而不是C字符串，Redis将获取字符串长度所需的复杂度从O(N)降低到了O(1),这确保了获取字符串长度的工作不会成为Redis的性能瓶颈。
	- 因为C字符串并不记录自身的长度信息，所以为了获取一个C字符串的长度，程序必须遍历整个字符串，对遇到的每个字符进行计数，直到遇到代表字符串结尾的空字符串为止，这个操作的复杂度为O(N)
	- 对于SDS来说，程序只要访问SDS的len属性，就可以立即知道字符串长度信息。（设置和更新SDS长度的工作是由SDS的API在执行时自动完成的，使用SDS无须进行任何手动修改长度的工作）


- 杜绝缓冲区溢出：除了获取字符串长度的复杂度高之外，C字符串不记录自身长度带来的另一个问题是容易造成缓冲区溢出；与C字符串不同，SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能性：当SDS API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的要求，如果不满足的话，API会自动将SDS的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用SDS既不需要手动修改SDS的空间大小，也不会出现前面所说的缓冲区溢出问题。

- 减少修改字符串时带来的内存重分配次数：
	- 因为C字符串并不记录自身的长度，所以对于一个包含了N个字符串的C字符串来说，这个C字符串的底层实现总是一个N+1个字符串的数组（额外的一个字符空间用于保存空字符）。因为C字符串的C字符串的长度和底层数组的长度之间存在着这种关联性，所以每次增长或者缩短一个C字符串，程序都总要对保存这个C字符串的数组进行一次内存重分配操作:如果程序执行的是增长字符串的操作，那么执行这个操作之前，程序需要先通过内存重分配来扩展底层数组的空间大小——如果忘了这一步就会产生缓冲区溢出；如果程序执行的是缩短字符串的操作，那么在执行这个操作之后，程序需要通过内存重分配来释放字符串不再使用的那部分空间——如果忘了这一步就会产生内存泄漏。
	- 为了避免C字符串的这种缺陷，SDS通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略。
		- 空间预分配：空间预分配用于优化SDS的字符串增长操作：当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所必须要的空间，还会为SDS分配额外的未使用空间。—— 如果对SDS进行修改之后，SDS的长度将小于1MB，那么程序分配和len属性同样大小的未使用空间，这时SDS len属性的值将和free属性的值相同；如果对SDS进行修改之后，SDS的长度将大于等于1MB，那么程序会分配1MB的未使用空间。（通过空间预分配策略，Redis可以减少连续执行字符串增长操作所需的内存重分配次数）
		- 惰性空间释放：当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录起来，并等待将来使用。

- 二进制安全：
	- C字符串中的字符必须符合某种编码（比如ASCII），并且除了字符串的末尾之外，字符串里面不能包含空字符，否则最先被程序读入的空字符将被误认为是字符串结尾，这些限制使得C字符串只能保存文本数据，而不能保存像图片、音频、视频、压缩文件这样的二进制数据。
	- 为了确保Redis可以适用于各种不同的使用场景，SDS的API都是二进制安全的，所有SDS API都会以处理二进制的方式来处理SDS存放在buf数组里的数据，程序不会对其中的数据做任何限制、过滤.....

- 兼容部分C字符串函数：C字符串可以使用所有<string.h>库中的函数，SDS可以使用一部分<string.h>库中的函数。



#### 2.embstr vs raw ####

Redis 的字符串有两种存储方式，在长度特别短时，使用 emb 形式存储 (embeded)，当长度超过 44 时，使用 raw 形式存储。

![](https://i.imgur.com/MSYanbA.png)


- embstr 存储形式是这样一种存储形式，它将 RedisObject 对象头和 SDS 对象连续存在一起，使用 malloc 方法一次分配。
- raw 存储形式不一样，它需要两次 malloc，两个对象头在内存地址上一般是不连续的。

通过分析Redis对象头结构体和SDS结构体，一个 RedisObject 对象头需要占据 16 字节的存储空间，SDS大小至少是3，那也就意味着分配一个字符串的最小空间占用为 19 字节 (16+3)。而内存分配器 jemalloc/tcmalloc 等分配内存大小的单位都是 2、4、8、16、32、64 等等，为了能容纳一个完整的 embstr 对象，jemalloc 最少会分配 32 字节的空间，如果字符串再稍微长一点，那就是 64 字节的空间。如果总体超出了 64 字节，Redis 认为它是一个大字符串，不再使用 emdstr 形式存储，而该用 raw 形式。



详细可以参考：[源码 1：丝分缕析 —— 探索「字符串」内部结构](https://juejin.im/book/5afc2e5f6fb9a07a9b362527/section/5b5af9d96fb9a04f83465ada)


要点总结：


- Redis 的字符串是动态字符串（SDS），是可以修改的字符串，内部结构实现上类似于 Java 的 ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配。扩容策略：字符串在长度小于 1M 之前，扩容空间采用加倍策略，也就是保留 100% 的冗余空间。当长度超过 1M 之后，为了避免加倍后的冗余空间过大而导致浪费，每次扩容只会多分配 1M 大小的冗余空间。需要注意的是字符串最大长度为 512M。（第一次创建没有冗余，执行append之后开始冗余，因为平时的应用中大多数字符串只有只读的需求，一旦遇到append指令意味着它是需要支持修改的，于是才给分配了冗余空间）

- Redis 的字符串有两种存储方式，在长度特别短时，使用 emb 形式存储 (embeded)，当长度超过 44 时，使用 raw 形式存储。


### 二、链表 ###


1.链表节点

每个链表节点使用一个adlist.h/listNode结构来表示：

	typedef struct listNode {
	
	    // 前置节点
	    struct listNode *prev;
	
	    // 后置节点
	    struct listNode *next;
	
	    // 节点的值
	    void *value;
	
	} listNode;

多个listNode可以通过prev和next指针组成双端链表：

![list结构和listNode组成的链表结构 ](https://i.imgur.com/E4gRbsJ.png)


	typedef struct list {
	
	    // 表头节点
	    listNode *head;
	
	    // 表尾节点
	    listNode *tail;
	
	    // 链表所包含的节点数量
	    unsigned long len;
	
	    // 节点值复制函数
	    void *(*dup)(void *ptr);
	
	    // 节点值释放函数
	    void (*free)(void *ptr);
	
	    // 节点值对比函数
	    int (*match)(void *ptr, void *key);
	
	} list;


虽然仅仅使用多个listNode结构就可以组成链表，但使用adlist.h/list来持有链表的话，操作起来会更方便。Redis的链表实现的特性可以总结如下：


- 双端： 链表节点带有 prev 和 next 指针， 获取某个节点的前置节点和后置节点的复杂度都是 O(1)
- 无环： 表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL ， 对链表的访问以 NULL 为终点
- 带表头指针和表尾指针： 通过 list 结构的 head 指针和 tail 指针， 程序获取链表的表头节点和表尾节点的复杂度为 O(1)
- 带链表长度计数器： 程序使用 list 结构的 len 属性来对 list 持有的链表节点进行计数， 程序获取链表中节点数量的复杂度为 O(1)
- 多态： 链表节点使用 void* 指针来保存节点值， 并且可以通过 list 结构的 dup 、 free 、 match 三个属性为节点值设置类型特定函数， 所以链表可以用于保存各种不同类型的值




### 三、字典 ###

#### （一）、字典的实现（数据结构） ####

1.哈希表节点

哈希表节点使用dictEntry结构表示，每个dictEntry结构都保存着一个键值对：

- key属性保存着键值对中的键，而v属性则保存着键值对中的值，其中键值对的值可以是一个指针，或者是一个uint4_t整数，又或者是一个int4_t整数。
- next属性是指向另一个哈希表节点的指针



		/* 哈希表节点 */
		typedef struct dictEntry {
		void *key; /* 键名 */
		union {
		void *val;
		uint64_t u64;
		int64_t s64;
		double d;
		} v; /* 值 */
		struct dictEntry *next; /* 指向下一个节点, 形成链表*/
		} dictEntry;



2.哈希表

Redis字典所使用的哈希表由dict.h/dictht结构定义：：

- table属性是一个数组，数组中的每个元素都是一个指向dict.h/dictEntry结构的指针
- size属性记录了哈希表的大小，也即是table数组的大小
- used属性则记录了哈希表目前已有节点（键值对）的数量
- sizemask属性的值总是等于size-1,这个属性和哈希值一起决定一个键应该被放到table数组的哪个索引上面。

	    /* 哈希表结构 */
    	typedef struct dictht {
    	dictEntry **table; /* 哈希表节点数组 */
    	unsigned long size; /* 哈希表大小 */
    	unsigned long sizemask; /* 哈希表大小掩码，用于计算哈希表的索引值，大小总是size - 1 */
    	unsigned long used; /* 哈希表已经使用的节点数量 */
    	} dictht;


![](https://i.imgur.com/Ki82mZN.png)


3.字典

Redis中的字典由dict.h/dict结构表示：

- type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不用的类型特定函数。
- privdata属性则保存了需要传给那些特定函数的可选参数。
- ht属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表，一般情况下，字典只使用ht[0]哈希表，ht[1]哈希表只会在对ht[0]哈希表进行rehash时使用。
- rehashidx记录了rehash目前的进度，如果目前没有在进行rehash,那么它的值为-1.



	    /* 字典结构 每个字典有两个哈希表，实现渐进式哈希时需要用在将旧表rehash到新表 */
    	typedef struct dict {
    	dictType *type; /* 类型特定函数 */
    	void *privdata; /* 保存类型特定函数需要使用的参数 */
    	dictht ht[2]; /* 保存的两个哈希表，ht[0]是真正使用的，ht[1]会在rehash时使用 */
    	long rehashidx; /* rehashing not in progress if rehashidx == -1 rehash进度，如果不等于-1，说明还在进行rehash */
    	unsigned long iterators; /* number of iterators currently running 正在运行中的遍历器数量 */
    	} dict;

其中，dictType 结构体定义如下

	/* 保存一连串操作特定类型键值对的函数 */
	typedef struct dictType {
	    uint64_t (*hashFunction)(const void *key); /* 哈希函数 */
	    void *(*keyDup)(void *privdata, const void *key); /* 复制键函数 */
	    void *(*valDup)(void *privdata, const void *obj); /* 复制值函数 */
	    int (*keyCompare)(void *privdata, const void *key1, const void *key2); /* 比较键函数 */
	    void (*keyDestructor)(void *privdata, void *key); /* 销毁键函数 */
	    void (*valDestructor)(void *privdata, void *obj); /* 销毁值函数 */
	} dictType;


![](https://i.imgur.com/lM1sEEd.png)


#### （二）、哈希算法 ####

当要将一个新的键值对添加到字典里面时，程序需要现根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。（当发生Hash冲突时，Redis的哈希表使用链地址法来解决键冲突（因为dictEntry节点组成的链表没有指向链表表尾的指针，所以为了速度考虑，程序总是将新节点添加到链表的表头位置，排在其他已有节点的前面））


#### （三）、rehash ####

Redis 哈希表不仅支持扩容，还支持缩容，这些工作可以通过执行rehash(重新散列)操作来完成，Redis对字典的哈希表执行rehash的步骤如下：

- 为字典的ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作以及ht[0]当前包含的键值对数量（也即是ht[0].used属性的值）:
	- 如果执行的是扩容操作，那么ht[1]的大小为第一个大于等于ht[0].used*2的2^n(2的n次方幂)；
	- 如果执行的是缩容操作，那么ht[1]的大小为第一个大于等于ht[0].used的2^n(2的n次方幂)
- 将保存在ht[0]中的所有键值对rehash到ht[1]上面：rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上。
- 当ht[0]包含的所有键值对都迁移到了ht[1]之后（ht[0]变为空表），释放ht[0],将ht[1]数值为ht[0]，并在ht[1]新创建一个空白哈希表，为下一次rehash做准备。


**Redis扩容条件** —— 当一下条件中的任意一个被满足时，程序会自动开始对哈希表执行扩容操作：


- 服务器目前没有执行BGSAVE、BGREWRITEAOF命令，并且哈希表的负载因子大于等于1.（其中，负载因子=哈希表已保存节点数量/哈希表大小）
- 服务器目前正在执行行BGSAVE、BGREWRITEAOF命令，并且哈希表的负载因子大于等于5.

**Redis缩容条件** —— 当哈希表的负载因子小于0.1时，程序自动开始对哈希表执行缩容操作。


#### （三）、渐进式rehash ####

为了避免rehash对服务器性能造成影响，服务器不是一次性将ht[0]里面的所有键值对全部rehash到ht[1],而是分多次、渐进式地将ht[0]里面的键值对慢慢地rehash到ht[1]。以下是哈希表渐进式rehash的详细步骤：

- 为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。
- 在字典中维持一个索引计数器变量rehashidx,并将它的值设置为0，标识rehash工作正式开始。
- 在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以为，还会顺带将ht[0]哈希表在rehashidx索引上的索引上的所有键值对rehash到ht[1],当rehash工作完成之后，程序将rehashidx属性的值增一。
- 随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash至ht[1],这时程序将rehashidx属性的值设为-1，标识rehash操作已完成。

渐进式rehash的好处在于它分而治之的方式，将rehash键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上，从而避免了集中式rehash而带来的庞大计算量。（说明：因为在进行渐进式rehash的过程中，字典会同时使用ht[0]和ht[1]两个哈希表，所以在渐进式rehash进行期间，字典的删除、查找、更新操作会在两个哈希表上进行，但是新添加到字典的键值对一律会被保存到ht[1]里面，而ht[0]则不再进行任何添加操作，这一措施保证了ht[0]包含的键值对数量会只减不增，并随着rehash操作的执行而最终变成空表）



### 四、跳跃表 ###


#### 1.跳跃表节点 ####

跳跃表是一种有序的数据结构，他通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的；
跳跃表支持平均O（logN），最坏O（N）复杂度的节点查找，还可以通过顺序性操作来批量处理节点。性能上和平衡树媲美，因为实现简单，常用来代替平衡树。在redis中，只在两个地方使用了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构。


跳跃表节点的实现由redis.h/zskiplistNode结构定义：

    typedef struct zskiplistNode {
	    robj *obj;  //保存的成员对象
	    double score;   //分值
	    struct zskiplistNode *backward; //后退指针
	    struct zskiplistLevel {
	    struct zskiplistNode *forward;  //前进指针
	    unsigned int span;  //跨度
	    } level[];  //层，柔型数组
    } zskiplistNode;
    

- 层 ： 跳跃表节点的Level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度，一般来说，层的数量越多，访问其他节点的速度就越快。（每次创建一个新跳跃表节点的时候，程序都根据幂次定律随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是层的“高度”）
- 前进指针： 每个层都有一个指向表尾方向的前进指针，用于从表头向表尾方向访问节点。
- 跨度：层的跨度用于记录两个节点之间的距离（初看上去很容易认为跨度和遍历操作有关，但实际并不是这样，遍历操作只使用前进指针就可以完成了，跨度实际上是用来计算排位(rank)的：在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位）：
	- 两个节点之间的跨度越大，他么相距得就越远。
	- 指向NULL的所有前进指针的跨度都为0，因为它们没有连向任何节点。
- 后退指针： 用于从表尾向表头方向访问节点。
- 分值：节点的分支(score)是一个double类型的浮点数，跳跃表中的所有节点都按分支从小到大来排序。
- 成员：节点的成员变量是一个指针，它指向一个字符串对象，而字符串对象则保存着一个SDS值。（在同一个跳跃表中，各个节点）



#### 2.跳跃表 ####

仅靠多个跳跃表节点就可以组成一个跳跃表，但通过一个zskiplist结构来持有这些节点，程序可以更方便地对整个跳跃表进行处理。

    typedef struct zskiplist {
	    struct zskiplistNode *header, *tail;//header指向跳跃表的表头节点，tail指向跳跃表的表尾节点
	    unsigned long length;   //跳跃表的长度或跳跃表节点数量计数器
	    int level;  //跳跃表中节点的最大层数（表头节点的层高并不计算在内）
    } zskiplist;



![](https://i.imgur.com/bNHB0YG.png)

### 五、整数集合 ###

整数集合(intset)是Redis用于保存整数值的集合抽象数据结构，它可以保存类型为int16_t、int32_t 或者 int64_t的整数值，并且保证集合中不会出现重复元素。每个intset.h/intset结构表示一个整数集合：


    typedef struct intset {
	    uint32_t encoding;  //编码方式，决定整数位宽是 16 位、32 位还是 64 位
	    uint32_t length;  //集合包含的元素数量
	    int8_t contents[];//保存元素的数组
    } intset;



- contents数组是整数集合的底层实现：整数集合的每个元素都是contents数组的一个数组项(item),各个项在数组中按值的大小从小到大有序地排列，并且数组中不包含任何重复项。
- length属性记录了整数集合包含的元素数量，也即是contents数组的长度。


#### 1.升级 ####

整数集合中可以存储int16_t、int32_t、int64_t这三种类型的整数，但在任一时刻，集合中所有元素的类型都是统一的。 
如果当前集合存储的元素是int16_t类型，当需要存入一个int32_t类型的整数时，Redis会分配一片新的内存空间，将每个元素的类型提升为int32_t，再将所有元素迁移至新数组中。 

- 整数集合的升级策略有两个好处，一个是提升整数集合的灵活性，另一个就是尽可能地节约内存。
- 整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。


### 六、压缩列表 ###

压缩列表（ziplist）是zset和hash键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现；另外，当一个哈希键只包含少量键值对，并且每个键值对的键和值要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做哈希键的底层实现。

压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存快组成的顺序型数据结构。一个压缩列表可以包含任意多个节点(entry),每个节点保存一个字节数组或者一个整数值。



### 四、对象 ###









附：


- [Redis官网](https://redis.io/)
- [Redis中文官方网站](http://www.redis.cn/)





































