### Redis使用篇——Redis 持久化(Persistence) ###
***

Redis的强劲性能很大程度上是由于其将所有数据都存储在了内存中，为了使Redis在重启之后仍能保证数据不丢失，需要将数据从内存中以某种形式同步到硬盘中，这一过程就是持久化。Redis支持两种方式的持久化，**一种是RDB方式，一种是AOF方式**。可以单独使用其中一种或将二者结合使用。

![RDB-AOF](https://img-blog.csdn.net/20130518180510266)


#### 一、RDB方式 ####


RDB方式的持久化是通过快照（snapshotting）完成的，当符合一定条件时Redis会自动将内存中的所有数据进行快照并存储在硬盘上。进行快照的条件可以由用户在配置文件中自定义，由两个参数构成：时间和改动的键的个数。当在指定的时间内被更改的键的个数大于指定的数值时就会进行快照。RDB是Redis默认采用的持久化方式，在配置文件中已经预置了3个条 件：

     save 900 1      #900秒内如果超过1个key被修改，则发起快照保存
     save 300 10     #300秒内容如超过10个key被修改，则发起快照保存
     save 60 10000

（save参数指定了快照条件，可以存在多个条件，条件之间是“或”的关系。如上所说，save  900 1的意思是在15分钟（900秒钟）内有至少一个键被更改则进行快照。如果想要禁用自动快照，只需要将所有的save参数删除即可。）

Redis默认会将快照文件存储在当前目录的dump.rdb文件中，可以通过配置dir和 dbfilename两个参数分别指定快照文件的存储路径和文件名。 
理清Redis实现快照的过程对我们了解快照文件的特性有很大的帮助。快照的过程如下：

![](http://img1.tuicool.com/NjYjYvF.png!web?_=6182478)

	（1）Redis使用fork函数复制一份当前进程（父进程）的副本（子进程）；
	（2）父进程继续接收并处理客户端发来的命令，而子进程开始将内存中的数据写入硬盘中的临时文件；
	（3）当子进程写入完所有数据后会用该临时文件替换旧的RDB文件，至此一次快照操作完成。

在执行fork的时候操作系统（类Unix操作系统）会使用写时复制（copy-on-write）策略，即 fork函数发生的一刻父子进程共享同一内存数据，当父进程要更改其中某片数据时（如执行一 个写命令），操作系统会将该片数据复制一份以保证子进程的数据不受影响，所以新的RDB文件存储的是执行fork一刻的内存数据。

通过上述过程可以发现Redis在进行快照的过程中不会修改RDB文件，只有快照结束后才会将旧的文件替换成新的，也就是说任何时候RDB文件都是完整的。这使得我们可以通过定时备份RDB文件来实现Redis数据库备份。RDB文件是经过压缩（可以配置rdbcompression参数 以禁用压缩节省CPU占用）的二进制格式，所以占用的空间会小于内存中的数据大小，更加利于传输。 除了自动快照，还可以手动发送SAVE或BGSAVE命令让Redis执行快照，两个命令的区别在于，前者是由主进程进行快照操作，会阻塞住其他请求，后者会通过fork子进程进行快照操作。

Redis启动后会读取RDB快照文件，将数据从硬盘载入到内存。根据数据量大小与结构和服务器性能不同，这个时间也不同。通常将一个记录一千万个字符串类型键、大小为1GB的快 照文件载入到内存中需要花费20～30秒钟。
通过RDB方式实现持久化，一旦Redis异常退出，就会丢失最后一次快照以后更改的所有数据。这就需要开发者根据具体的应用场合，通过组合设置自动快照条件的方式来将可能发 生的数据损失控制在能够接受的范围。如果数据很重要以至于无法承受任何损失，则可以考虑使用AOF方式进行持久化。

**RDB的优点**：



- RDB 是一个非常紧凑（compact）的文件，它保存了Redis 在某个时间点上的数据集。这种文件非常适合用于进行备份：比如说，你可以在最近的24 小时内，每小时备份一次RDB 文件，并且在每个月 的每一天，也备份一个RDB 文件。这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。
- RDB 非常适用于灾难恢复（disaster recovery）：它只有一个文件，并且内容都非常紧凑，可以（在加密后）将它传送到别的数据中心，或者亚马逊S3 中。
- RDB 可以最大化Redis 的性能：父进程在保存RDB 文件时唯一要做的就是fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘I/O 操作。
-  RDB 在恢复大数据集时的速度比AOF 的恢复速度要快。


**RDB的缺点**：



-  如果你需要尽量避免在服务器故障时丢失数据，那么RDB不适合你。虽然Redis 允许你设置不同的保存点（save point）来控制保存RDB 文件的频率，但是，因为RDB 文件需要保存整个数据集的状态，所以它并不是一个轻松的操作。因此你可能会至少5 分钟才保存一次RDB 文件。在这种情况下，一旦发生故障停机，你就可能会丢失好几分钟的数据。
-  每次保存RDB 的时候，Redis 都要fork() 出一个子进程，并由子进程来进行实际的持久化工作。在数据集比较庞大时，fork() 可能会非常耗时，造成服务器在某某毫秒内停止处理客户端；如果数据集非常巨大，并且CPU 时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒。虽然AOF 重写也需要进行fork() ，但无论AOF 重写的执行间隔有多长，数据的耐久性都不会有任何损失。



#### 二、AOF方式 ####

![](http://dl2.iteye.com/upload/attachment/0112/8399/5f2e2dc2-b66a-3842-b5e8-34855d9788d8.jpg)

**1.AOF概述：**

默认情况下Redis没有开启AOF（append only file）方式的持久化，可以通过appendonly参数开启：

	appendonly yes    #启用aof持久化方式

开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认 文件名是appendonly.aof，可以通过appendfilename参数修改：

	appendfilename appendonly.aof   

在启动时Redis会逐个执行AOF文件中的命令来将硬盘中的数据载入到内存中，载入的速度相较RDB会慢一些。

需要注意的是虽然每次执行更改数据库内容的操作时，AOF都会将命令记录在AOF文件中，但是事实上，由于操作系统的缓存机制，数据并没有真正地写入硬盘，而是进入了系统的硬盘缓存。在默认情况下系统每30秒会执行一次同步操作，以便将硬盘缓存中的内容真正地写入硬盘，在这30秒的过程中如果系统异常退出则会导致硬盘缓存中的数据丢失。一般来讲启用AOF持久化的应用都无法容忍这样的损失，这就需要Redis在写入AOF文件后主动要求系统将缓存内容同步到硬盘中。在Redis中我们可以通过appendfsync参数设置同步的时机：

	# appendfsync always  #每次收到写命令就立即强制写入磁盘，最慢的，但是保证完全的持久化，不推荐使用
	appendfsync everysec  #每秒钟强制写入磁盘一次，在性能和持久化方面做了很好的折中，推荐
	# appendfsync no      #完全依赖os，性能最好,持久化没保证

默认情况下Redis采用everysec 规则，即每秒执行一次同步操作。always表示每次执行写入都会执行同步，这是最安全也是最慢的方式。no表示不主动进行同步操作，而是完全交由操作系统来做（即每30秒一次），这是最快但最不安全的方式。一般情况下使用默认值everysec就足够了，既兼顾了性能又保证了安全。 Redis允许同时开启AOF和RDB，既保证了数据安全又使得进行备份等操作十分容易。此时重新启动Redis后Redis会使用AOF文件来恢复数据，因为AOF方式的持久化可能丢失的数据更少。



**2.AOF重写：**

aof 的方式也同时带来了另一个问题。持久化文件会变的越来越大。例如我们调用incr test命令100次，文件中必须保存全部的100条命令，其实有99条都是多余的。因为要恢复数据库的状态其实文件中保存一条set test 100就够了。为了压缩aof的持久化文件。redis提供了bgrewriteaof命令。收到此命令redis将使用与快照类似的方式将内存中的数据以命令的方式保存到临时文件中，最后替换原来的文件。

**误区：所谓的“重写”其实是一个有歧义的词语， 实际上， AOF 重写并不需要对原有的 AOF 文件进行任何写入和读取， 它针对的是数据库中键的当前值。**

![](http://dl2.iteye.com/upload/attachment/0112/8401/34167c00-296e-36cb-b5c4-92c57a758d70.jpg)

具体过程如下：

	 1. redis调用fork ，现在有父子两个进程
	 2. 子进程根据内存中的数据库快照，往临时文件中写入重建数据库状态的命令
	 3. 父进程继续处理client请求，除了把写命令写入到原来的aof文件中。同时把收到的写命令缓存起来。这样就能保证如果子进程重写失败的话并不会出问题。
	 4. 当子进程把快照内容以命令方式写到临时文件中后，子进程发信号通知父进程。然后父进程把缓存的写命令也写入到临时文件。
	 5. 现在父进程可以使用临时文件替换老的aof文件，并重命名，后面收到的写命令也开始往新的aof文件中追加。
	 （需要注意到是重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似。 ）


  由于Redis的单线程模型，理论上每个redis实例只会用到一个CPU, 也就是说可以在一台多核的服务器上部署多个实例（实际就是这么做的）。但是Redis的AOF重写是通过fork出一个Redis进程来实现的，所以有经验的Redis开发和运维人员会告诉你，在一台服务器上要预留一半的内存（防止出现AOF重写集中发生，出现swap和OOM）。

![](http://dl2.iteye.com/upload/attachment/0112/8405/0759c01b-b19a-3516-82d2-be9697aaa4ca.jpg)



**3.AOF的优点：**



-  使用AOF 持久化会让Redis 变得非常耐久（much more durable）：你可以设置不同的fsync 策略， 比如无fsync ，每秒钟一次fsync ，或者每次执行写入命令时fsync 。AOF 的默认策略为每秒钟 fsync 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据（fsync 会在后台线程执行，所以主线程可以继续努力地处理命令请求）。
-   AOF 文件是一个只进行追加操作的日志文件（append only log），因此对AOF文件的写入不需要进行seek ，即使日志因为某些原因而包含了未写入完整的命令（比如写入时磁盘已满，写入中途停机， 等等），redis-check-aof 工具也可以轻易地修复这种问题。
-    Redis 可以在AOF 文件体积变得过大时，自动地在后台对AOF进行重写：重写后的新AOF文件包含了恢复当前数据集所需的最小命令集合。整个重写操作是绝对安全的，因为Redis 在创建新AOF 文件的过程中，会继续将命令追加到现有的AOF文件里面，即使重写过程中发生停机，现有的AOF 文件也不会丢失。而一旦新AOF 文件创建完毕，Redis 就会从旧AOF 文件切换到新AOF文件，并开始对新AOF文件进行追加操作。
-    AOF 文件有序地保存了对数据库执行的所有写入操作，这些写入操作以Redis 协议的格式保存，因此AOF 文件的内容非常容易被人读懂，对文件进行分析（parse）也很轻松。导出（export）AOF 文件也非常简单：举个例子，如果你不小心执行了FLUSHALL 命令，但只要AOF文件未被重写，那么只要停止服务器，移除AOF文件末尾的FLUSHALL 命令，并重启Redis ，就可以将数据集恢复 到FLUSHALL 执行之前的状态。



**4.AOF的缺点：**

对于相同的数据集来说，AOF 文件的体积通常要大于RDB 文件的体积。

	

- 根据所使用的fsync 策略，AOF 的速度可能会慢于RDB 。在一般情况下，每秒fsync 的性能依然 非常高，而关闭fsync 可以让AOF 的速度和RDB 一样快，即使在高负荷之下也是如此。不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。
- AOF 在过去曾经发生过这样的bug ：因为个别命令的原因，导致AOF 文件在重新载入时，无法将数据集恢复成保存时的原样。（举个例子，阻塞命令BRPOPLPUSH 就曾经引起过这样的bug 。）测试套件里为这种情况添加了测试：它们会自动生成随机的、复杂的数据集，并通过重新载入这些数据来 确保一切正常。虽然这种bug 在AOF 文件中并不常见，但是对比来说，RDB 几乎是不可能出现这种 bug 的。


#### 三、RDB | AOF 综合问题 ####

**1.如何选型？**

一般来说，如果想达到足以媲美PostgreSQL 的数据安全性，你应该同时使用两种持久化功能。 如果你非常关心你的数据，但仍然可以承受数分钟以内的数据丢失，那么你可以只使用RDB 持久化。（有很多用户都只使用AOF 持久化，但我们并不推荐这种方式：因为定时生成RDB 快照（snapshot）非常便于进行数据库备份，并且RDB 恢复数据集的速度也要比AOF 恢复的速度要快，除此之外，使用RDB 还可以避免之前提到的AOF 程序的bug 。 ）
     

**2.怎么从RDB 持久化切换到AOF 持久化？**

在Redis 2.2 或以上版本，可以在不重启的情况下，从RDB 切换到AOF ：
          


- 1）. 为最新的dump.rdb 文件创建一个备份。
- 2）. 将备份放到一个安全的地方。
- 3）. 执行以下两条命令：

		redis-cli> CONFIG SET appendonly yes  #第一条命令开启了AOF 功能：Redis 会阻塞直到初始AOF 文件创建完成为止，之后Redis 会继续处理命令请求，并开始将写入命令追加到AOF 文件末尾。
		redis-cli> CONFIG SET save ""         #第二条命令用于关闭RDB 功能。这一步是可选的，如果你愿意的话，也可以同时使用RDB 和AOF 这两种持久化功能。

4）. 确保命令执行之后，数据库的键的数量没有改变。
5）. 确保写命令会被正确地追加到AOF 文件的末尾。
     
（Note: 别忘了在redis.conf 中打开AOF 功能！否则的话，服务器重启之后，之前通过CONFIG SET 设置的配置就会被遗忘，程序会按原来的配置来启动服务器。）
     

**3.RDB和AOF之间的相互作用**

在版本号大于等于2.4 的Redis 中，BGSAVE 执行的过程中，不可以执行BGREWRITEAOF 。反过来说， 在BGREWRITEAOF 执行的过程中，也不可以执行BGSAVE 。 这可以防止两个Redis 后台进程同时对磁盘进行大量的I/O 操作。 如果BGSAVE 正在执行，并且用户显示地调用BGREWRITEAOF 命令，那么服务器将向用户回复一个OK 状态，并告知用户，BGREWRITEAOF 已经被预定执行：一旦BGSAVE 执行完毕，BGREWRITEAOF 就 会正式开始。 当Redis 启动时，如果RDB 持久化和AOF 持久化都被打开了，那么程序会优先使用AOF文件来恢复数 据集，因为AOF文件所保存的数据通常是最完整的。
    

**4.如果AOF文件出错了怎么办？**
     
服务器可能在程序正在对AOF 文件进行写入时停机，如果停机造成了AOF 文件出错（corrupt），那么 Redis 在重启时会拒绝载入这个AOF 文件，从而确保数据的一致性不会被破坏。当发生这种情况时，可以用以下方法来修复出错的AOF 文件：
          
	1）. 为现有的AOF 文件创建一个备份。
	2）. 使用Redis 附带的redis-check-aof 程序，对原来的AOF 文件进行修复 ———— $ redis-check-aof --fix
	3）. （可选）使用diff -u 对比修复后的AOF文件和原始AOF 文件的备份，查看两个文件之间的不同之处。
	4）. 重启Redis 服务器，等待服务器载入修复后的AOF文件，并进行数据恢复。


#### 四、Redis 4.0 混合持久化 ####

重启 Redis 时，我们很少使用 rdb 来恢复内存状态，因为会丢失大量数据。我们通常使用 AOF 日志重放，但是重放 AOF 日志性能相对 rdb 来说要慢很多，这样在 Redis 实例很大的情况下，启动需要花费很长的时间。

Redis 4.0 为了解决这个问题，带来了一个新的持久化选项——混合持久化。将 rdb 文件的内容和增量的 AOF 日志文件存在一起。这里的 AOF 日志不再是全量的日志，而是自持久化开始到持久化结束的这段时间发生的增量 AOF 日志，通常这部分 AOF 日志很小。

![](https://i.imgur.com/UEcZ5Al.png)

于是在 Redis 重启的时候，可以先加载 rdb 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，重启效率因此大幅得到提升。

附录：



- [《Redis 设计与实现 —— RDB》](https://redisbook.readthedocs.io/en/latest/internal/rdb.html)
- [《Redis 设计与实现 —— AOF》](https://redisbook.readthedocs.io/en/latest/internal/aof.html)
































