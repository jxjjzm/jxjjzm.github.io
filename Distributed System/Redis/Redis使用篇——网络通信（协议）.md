### Redis使用篇——网络通信（协议） ###
***

### 一、连接的建立 ###

Redis通过监听一个TCP端口或者Unix socket的方式来接收来自客户端的连接，当一个连接建立后，Redis 内部会进行以下一些操作：

- 首先，客户端 socket 会被设置为非阻塞模式，因为 Redis 在网络事件处理上采用的是非阻塞多路复用模型。
- 然后为这个socket 设置 TCP_NODELAY 属性，禁用 [Nagle 算法](http://baike.baidu.com/view/2468335.htm)。
- 然后创建一个 readable 的文件事件用于监听这个客户端 socket 的数据发送。
- 当客户端连接被初始化后，Redis会查看目前的连接数，然后对比配置好的 maxclients 值，如果目前连接数已经达到最大连接数 maxclients 了（在 Redis2.4 中，最大连接数是被直接硬编码在代码里面的，而在2.6版本中这个值变成可配置的。maxclients 的默认值是 10000，你也可以在 redis.conf 中对这个值进行修改。当然，这个值只是 Redis 一厢情愿的值，Redis 还会照顾到系统本身对进程使用的文件描述符数量的限制。），那么说明这个连接不能再接收，Redis 会直接返回客户端一个连接错误，并马上关闭掉这个连接。（注：先建立连接，后检查，然后再断开，这样提高了并发量。）


为什么 Redis 中要使用 I/O 多路复用这种技术呢？

首先，Redis 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，而 I/O 多路复用就是为了解决这个问题而出现的。

### 附：Redis线程IO模型 ###

在正式开扯之前，不妨先温习下前面[浅析分布式网络通信](https://github.com/jxjjzm/jxjjzm.github.io/blob/master/Distributed%20System/%E6%9D%82%E8%B0%88/%E6%B5%85%E6%9E%90%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1.md)一文中的“网络通信模型（IO模型）”模块。



问：Redis 单线程为什么还能这么快？

- 纯内存访问，所有数据都在内存中，所有的运算都是内存级别的运算，内存响应时间为纳秒级别，这是redis达到万级每秒的基础。
- 因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。（采用单线程，避免了不必要的上下文切换和竞争条件，不存在多线程导致的切换而消耗CPU，不用考虑各种锁的问题，不存在加锁和释放锁的的操作，没有因为可能出现的死锁而导致的性能消耗。（线程是需要内存开销的，1个线程可能需要2M 存放栈，1000个线程就需要2G的内存））。
- redis单线程如何处理那么多并发客户端连接？回答：非阻塞IO，使用I/O多路复用技术（linux下可以使用epoll/poll/select）。多路复用是指使用一个线程来检查多个文件符FD（socket，文件，管道）的就绪状态；比如select和poll函数，传入多个文件描述符，一个文件符就绪，则返回，否则阻塞直到超时。

Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件：文件事件和时间事件

- 文件事件：Redis服务器通过套接字与客户端（或者其他Redis服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与与客户端（或者其他Redis服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作。
- 时间事件：Redis服务器中的一些操作需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。

#### （一）文件事件 ####

Redis 基于 Reactor 模式开发了自己的网络事件处理器： 这个处理器被称为文件事件处理器（file event handler）：


- 文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。
- 当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。


文件事件处理器主要有四个组成部分，它们分别是套接字、I/O多路复用程序、文件事件分派器、以及事件处理器。

![](http://dl2.iteye.com/upload/attachment/0112/8037/df474adc-485e-384e-845e-6c68cc96b961.jpg)



- 文件事件是对套接字操作的抽象， 每当一个套接字准备好执行连接应答（accept）、写入、读取、关闭等操作时， 就会产生一个文件事件。 因为一个服务器通常会连接多个套接字， 所以多个文件事件有可能会并发地出现。
- I/O 多路复用程序负责监听多个套接字， 并向文件事件分派器传送那些产生了事件的套接字。尽管多个文件事件可能会并发地出现， 但 I/O 多路复用程序总是会将所有产生事件的套接字都入队到一个队列里面， 然后通过这个队列， 以有序（sequentially）、同步（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字： 当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕）， I/O 多路复用程序才会继续向文件事件分派器传送下一个套接字。

![](http://dl2.iteye.com/upload/attachment/0112/8144/1c76275e-925b-38a3-b2f0-3eb764cf6b52.jpg)

Redis 的 I/O 多路复用程序的所有功能都是通过包装常见的 select 、 epoll 、 evport 和 kqueue 这些 I/O 多路复用函数库来实现的， 每个 I/O 多路复用函数库在 Redis 源码中都对应一个单独的文件， 比如 ae_select.c 、 ae_epoll.c 、 ae_kqueue.c ， 诸如此类。因为 Redis 为每个 I/O 多路复用函数库都实现了相同的 API ， 所以 I/O 多路复用程序的底层实现是可以互换的

![](https://i.imgur.com/XRLPtdC.png)

- 文件事件分派器接收 I/O 多路复用程序传来的套接字， 并根据套接字产生的事件的类型， 调用相应的事件处理器。
- 服务器会为执行不同任务的套接字关联不同的事件处理器， 这些处理器是一个个函数， 它们定义了某个事件发生时， 服务器应该执行的动作。Redis 为文件事件编写了多个处理器， 这些事件处理器分别用于实现不同的网络通讯需求， 比如说：
	- 为了对连接服务器的各个客户端进行应答， 服务器要为监听套接字关联连接应答处理器。
	- 为了接收客户端传来的命令请求， 服务器要为客户端套接字关联命令请求处理器。
	- 为了向客户端返回命令的执行结果， 服务器要为客户端套接字关联命令回复处理器。
	- 当主服务器和从服务器进行复制操作时， 主从服务器都需要关联特别为复制功能编写的复制处理器。
	- ......

让我们来追踪一次 Redis 客户端与服务器进行连接并发送命令的整个过程， 看看在过程中会产生什么事件， 而这些事件又是如何被处理的。

![](http://redisbook.com/_images/graphviz-ecd9b3ff243e2f34204c0f9f2a590058bf262d84.png)

假设一个 Redis 服务器正在运作， 那么这个服务器的监听套接字的 AE_READABLE 事件应该正处于监听状态之下， 而该事件所对应的处理器为连接应答处理器。

如果这时有一个 Redis 客户端向服务器发起连接， 那么监听套接字将产生 AE_READABLE 事件， 触发连接应答处理器执行： 处理器会对客户端的连接请求进行应答， 然后创建客户端套接字， 以及客户端状态， 并将客户端套接字的 AE_READABLE 事件与命令请求处理器进行关联， 使得客户端可以向主服务器发送命令请求。

之后， 假设客户端向主服务器发送一个命令请求， 那么客户端套接字将产生 AE_READABLE 事件， 引发命令请求处理器执行， 处理器读取客户端的命令内容， 然后传给相关程序去执行。

执行命令将产生相应的命令回复， 为了将这些命令回复传送回客户端， 服务器会将客户端套接字的 AE_WRITABLE 事件与命令回复处理器进行关联： 当客户端尝试读取命令回复的时候， 客户端套接字将产生 AE_WRITABLE 事件， 触发命令回复处理器执行， 当命令回复处理器将命令回复全部写入到套接字之后， 服务器就会解除客户端套接字的 AE_WRITABLE 事件与命令回复处理器之间的关联。

#### （二）时间事件 ####

时间事件分为定时事件和周期性事件：定时事件只在指定的时间到达一次，而周期性事件则每隔一段时间到达一次。（文件事件和时间事件之间是合作关系，服务器会轮流处理这两种事件，并且处理事件的过程中也不会进行抢占。（时间事件的实际处理时间通常会比设定的到达时间晚一些））

![](https://i.imgur.com/TGEfOOs.png)


### 二、服务端处理顺序 ###

如果有多个客户端连接上 Redis，并且都向 Redis 发送命令，那么 Redis 服务端会先处理哪个客户端的请求呢？答案其实并不确定，主要与两个因素有关，一是客户端对应的 socket 对应的数字的大小，二是 kernal 报告各个客户端事件的先后顺序。Redis 处理一个客户端传来数据的步骤如下：


- 它对触发事件的 socket 调用一次 read()，只读一次（而不是把这个 socket 上的消息读完为止），是为了防止由于某个别客户端持续发送太多命令，导致其它客户端的请求长时间得不到处理的情况。
- 当然，当这一次 read() 调用完成后，它里面无论包含多少个命令，都会被一次性顺序地执行。这样就保证了对各个客户端命令的公平对待。


### 三、通信协议 ###

![](http://dl2.iteye.com/upload/attachment/0112/8146/550baa12-6f34-33c3-ae03-fd7bf60875f7.jpg)

我们知道客户端和服务器通过 TCP 连接来进行数据交互， 服务器默认的端口号为 6379 。Redis 服务器接受命令以及命令的参数。服务器会在接到命令之后，对命令进行处理，并将命令的回复传送回客户端（客户端和服务器发送的命令或数据一律以 \r\n （CRLF）结尾）。

Redis通信协议是Redis客户端与Redis之间交流的语言，通信协议规定了命令和返回值的格式。Redis支持两种通信协议，一种是二进制安全的统一请求协议（统一请求协议在 Redis 1.2 版本中引入， 并最终在 Redis 2.0 版本成为 Redis 服务器通信的标准方式。），一种是比较直观的便于在telnet程序中输入的简单协议。这两种协议只是命令的格式有区别，命令返回值的格式是一样的。

#### 1.请求 ####

统一请求协议的一般形式：

	*<参数数量> CR LF
	$<参数 1 的字节数量> CR LF
	<参数 1 的数据> CR LF
	...
	$<参数 N 的字节数量> CR LF
	<参数 N 的数据> CR LF

举个例子（set mykey myvalue）， 以下是一个命令协议的打印版本：

	*3
	$3
	SET
	$5
	mykey
	$7
	myvalue

这个命令的实际协议值如下：

	"*3\r\n$3\r\nSET\r\n$5\r\nmykey\r\n$7\r\nmyvalue\r\n"


#### 2.回复 ####

Redis 命令会返回多种不同类型的回复。通过检查服务器发回数据的第一个字节， 可以确定这个回复是什么类型：


- 状态回复（status reply）： 一个状态回复（或者单行回复，single line reply）是一段以 "+" 开始、 "\r\n" 结尾的单行字符串。
- 错误回复（error reply）： 错误回复和状态回复非常相似， 它们之间的唯一区别是， 错误回复的第一个字节是 "-" ， 而状态回复的第一个字节是 "+" 。错误回复只在某些地方出现问题时发送： 比如说， 当用户对不正确的数据类型执行命令， 或者执行一个不存在的命令， 等等。一个客户端库应该在收到错误回复时产生一个异常。
- 整数回复（integer reply）： 整数回复就是一个以 "：" 开头， CRLF 结尾的字符串表示的整数。返回整数回复的其中两个命令是 INCR 和 LASTSAVE 。 被返回的整数没有什么特殊的含义， INCR 返回键的一个自增后的整数值， 而 LASTSAVE 则返回一个 UNIX 时间戳， 返回值的唯一限制是这些数必须能够用 64 位有符号整数表示。整数回复也被广泛地用于表示逻辑真和逻辑假： 比如 EXISTS 和 SISMEMBER 都用返回值 1 表示真， 0 表示假。
- 批量回复（bulk reply）： 只有一个参数的回复格式被称为批量回复。批量回复的第一个字节是 "$"，接下来跟着的是表示实际回复长度的数字值，之后跟着一个 CRLF，再后面跟着的是实际回复数据，最末尾是另一个 CRLF
- 多条批量回复（multi bulk reply）： 将列表的多个项返回给客户端的， 这种回复格式被称为多条批量回复。多条批量回复的第一个字节为 "*" ， 后跟一个字符串表示的整数值， 这个值记录了多条批量回复所包含的回复数量， 再后面是一个 CRLF 。


详细了解可参考[交头接耳 —— 通信协议](https://juejin.im/book/5afc2e5f6fb9a07a9b362527/section/5afc39496fb9a07ab458d0f1)。
















































































































































