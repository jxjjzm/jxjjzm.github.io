### Redis使用篇——Redis主从复制（master-slave replication） ###
***
### 一、Redis复制概述 ###

通过持久化功能，Redis保证了即使在服务器重启的情况下也不会损失（或少量损失）数据。但是由于数据是存储在一台服务器上的，如果这台服务器的硬盘出现故障，也会导致数据丢失。为了避免单点故障，我们希望将数据库复制多个副本以部署在不同的服务器上，即使有一台服务器出现故障其他服务器依然可以继续提供服务。这就要求当一台服务器上的数据库更新后，可以自动将更新的数据同步到其他服务器上，Redis提供了复制（replication）功能可以自动实现同步的过程。

#### 1.Redis复制概论 ####

数据库复制指的是发生在不同数据库实例之间，单向的信息传播的行为，通常由被复制方和复制方组成，被复制方和复制方之间建立网络连接，复制方式通常为被复制方主动将数据发送到复制方，复制方接收到数据存储在当前实例，最终目的是为了保证双方的数据一致、同步。


![](http://ww1.sinaimg.cn/large/7cc829d3jw1f4d3beuv8lj20p008ygm3.jpg)


#### 2.Redis复制方式 ####

Redis的复制方式有两种，一种是主（master）-从（slave）模式，一种是从（slave）-从（slave）模式，因此Redis的复制拓扑图会丰富一些，可以像星型拓扑，也可以像个有向无环：

![](http://ww3.sinaimg.cn/large/7cc829d3jw1f4d3bft2lfj214e0gewg6.jpg)


#### 3.Redis复制优缺点及特性 ####

**I、优点**

通过配置多个Redis实例，数据备份在不同的实例上，主库专注写请求，从库负责读请求，这样的好处主要体现在下面几个方面：

- 高可用性：在一个Redis集群中，如果master宕机，slave可以介入并取代master的位置，因此对于整个Redis服务来说不至于提供不了服务，这样使得整个Redis服务足够安全。
- 高性能：在一个Redis集群中，master负责写请求，slave负责读请求，这么做一方面通过将读请求分散到其他机器从而大大减少了master服务器的压力，另一方面slave专注于提供读服务从而提高了响应和读取速度。
- 水平扩展性：通过增加slave机器可以横向（水平）扩展Redis服务的整个查询服务的能力。


**II、缺点**

复制提供了高可用性的解决方案，但同时引入了分布式计算的复杂度问题，认为有两个核心问题：

- 数据一致性问题，如何保证master服务器写入的数据能够及时同步到slave机器上。
- 编程复杂，如何在客户端提供读写分离的实现方案，通过客户端实现将读写请求分别路由到master和slave实例上。

（复制实时性和数据一致性矛盾 ———— Redis提供了提高数据一致性的解决方案，一致性程度的增加虽然使得我能够更信任数据，但是更好的一致性方案通常伴随着性能的损失，从而减少了吞吐量和服务能力。然而我们希望系统的性能达到最优，则必须要牺牲一致性的程度，因此Redis的复制实时性和数据一致性是存在矛盾的。）


### 二、Redis复制配置及原理 ###

#### 1.配置 ####

在Redis中建立复制的配置方式有三种：


- 在从Redis服务器的redis.conf中写入slaveof masterip masterport即可，主Redis服务器不需要做任何配置
- 在启动Redis服务器的时候，指定主服务器，redis-server --slaveof masterip masterport
- 在从节点客户端指定主服务器，redis> SLAVEOF masterip masterport，SLAVEOF命令会停止与原有主服务器的同步，转而向新主服务器进行同步


#### 2.原理 ####

**I、全量复制**

![](http://ww2.sinaimg.cn/large/7cc829d3jw1f4d3bh8h4rj20mi0jywfk.jpg)

Redis的复制功能分为同步(sync)和命令传播(command propagate)两个操作：
- 同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态。
- 命令传播操作则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致状态。

**（1）同步**

当客户端向从服务器发送SLAVEOF命令，要求从服务器复制主服务器时，从服务器首先需要执行同步操作，也即是将从服务器的数据库状态更新至主服务器当前所处的数据库状态。

从服务器对主服务器的同步操作需要通过向主服务器发送SYNC命令来完成，以下是SYNC命令的执行步骤：

- 1）从服务器向主服务器发送SYNC命令。
- 2）收到SYNC命令的主服务器执行BGSAVE命令，在后台生成一个RDB文件，并使用一个缓冲区记录从现在开始执行的所有写命令。
- 3）当主服务器的BGSAVE命令执行完毕时，主服务器会将BGSAVE命令生成的RDB文件发送给从服务器，从服务器接受并载入这个RDB文件，将自己的数据库状态更新至主服务器执行BGSAVE命令时的数据库状态。
- 4）主服务器将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行这些写命令，将自己的数据库状态更新至主服务器数据库当前所处的状态。

**（2）命令传播**

在同步操作执行完毕之后，主从服务器两者的数据库将达到一致状态，但这种一致并不是一成不变的，每当主服务器执行客户端发送的写命令时，主服务器的数据库就有可能会被修改，并导致主从服务器状态不再一致。为了让主从服务器再次回到一致状态，主服务器需要对从服务器执行命令传播操作：主服务器会将自己执行的写命令，也即是造成主从服务器不一致的那条写命令，发送给从服务器执行，当从服务器执行了相同的写命令之后，主从服务器将再次回到一致状态。


![](http://images2015.cnblogs.com/blog/631180/201603/631180-20160310164439163-353212676.png)


**II、增量复制**

![](http://ww3.sinaimg.cn/large/7cc829d3jw1f4d3biaumhj20xc0h275j.jpg)

在Redis2.6之前，主从断开重连后，一定会进行一次快照操作然后将快照发送给从数据库，即使断开期间只有几条命令被执行，这就使得断开重连后的数据恢复过程效率很低。为了解决旧版本复制功能在处理断开重连情况时的低效问题，Redis从2.8版本开始，主从断开重连后会根据断开之前最新的命令偏移量进行增量复制

![](https://i.imgur.com/EfTyfwX.png)


- 1）主服务器在同步命令到从服务器的时候，会先将命令放入一个缓冲队列中并记录一个复制偏移量，同时主从服务器都会记录一个主服务器的运行ID。
- 2）当主从断开重连后，会判断主服务器保存的运行ID和从服务器发送过来的运行ID是否相同，相同则将从复制偏移量开始往后的所有命令一并发送给从服务器。如果不同，则进行一次复制初始化（将RDB快照和和这期间缓存起来的命令一并发送给主服务器）。
- 3）缓冲队列的大小默认是1MB，可以在redis.conf中的配置项repl-backlog-size进行设置，还有一个配置项repl-backlog-ttl，表示当主从断开后，缓冲队列的缓存时间。


![](http://images2015.cnblogs.com/blog/631180/201603/631180-20160310181751413-120441435.png)





### 三、补充 ###


#### 1.无盘复制 ####

主节点在进行快照同步时，会进行很重的文件 IO 操作，特别是对于非 SSD 磁盘存储时，快照会对系统的负载产生较大影响。特别是当系统正在进行 AOF 的 fsync 操作时如果发生快照，fsync 将会被推迟执行，这就会严重影响主节点的服务效率。

所以从 Redis 2.8.18 版开始支持无盘复制。所谓无盘复制是指主服务器直接通过套接字将快照内容发送到从节点，生成快照是一个遍历的过程，主节点会一边遍历内存，一边将序列化的内容发送到从节点，从节点还是跟之前一样，先将接收到的内容存储到磁盘文件中，再进行一次性加载。


#### 2.Wait指令 ####

Redis 的复制是异步进行的，wait 指令可以让异步复制变身同步复制，确保系统的强一致性 (不严格)。wait 指令是 Redis3.0 版本以后才出现的。


	> set key value
	OK
	> wait 1 0
	(integer) 1


wait 提供两个参数，第一个参数是从库的数量 N，第二个参数是时间 t，以毫秒为单位。它表示等待 wait 指令之前的所有写操作同步到 N 个从库 (也就是确保 N 个从库的同步没有滞后)，最多等待时间 t。如果时间 t=0，表示无限等待直到 N 个从库同步完成达成一致。


假设此时出现了网络分区，wait 指令第二个参数时间 t=0，主从同步无法继续进行，wait 指令会永远阻塞，Redis 服务器将丧失可用性。













































