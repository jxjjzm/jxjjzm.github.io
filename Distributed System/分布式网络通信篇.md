### 分布式网络通信篇 ###

***

### 一、TCP/IP ###

TCP/IP 指传输控制协议/网际协议（Transmission Control Protocol / Internet Protocol），是供已连接因特网的计算机进行通信的通信协议，TCP/IP定义了电子设备（比如计算机）如何连入因特网以及数据如何在它们之间传输的标准。

TCP/IP 是基于 TCP 和 IP 这两个最初的协议之上的不同的通信协议的大集合。TCP/IP 意味着 TCP 和 IP 在一起协同工作 （TCP 负责应用软件（比如您的浏览器）和网络软件之间的通信，IP 负责计算机之间的通信；TCP 负责将数据分割并装入 IP 包，然后在它们到达的时候重新组合它们，IP 负责将包发送至接受者）。在 TCP/IP 中包含一系列用于处理数据通信的协议：

![](http://new.51cto.com/files/uploadimg/20090215/151046863.jpg)

- TCP (传输控制协议) - 应用程序之间通信
- UDP (用户数据包协议) - 应用程序之间的简单通信
- IP (网际协议) - 计算机之间的通信
- ICMP (因特网消息控制协议) - 针对错误和状态
- DHCP (动态主机配置协议) - 针对动态寻址


TCP/IP协议栈主要分为四层:应用层、传输层、网络层、数据链路层,每层都有相应的协议（所谓的协议就是双方进行数据传输的一种格式。），如下图：

![](http://blog.chinaunix.net/attachment/201304/27/26833883_1367053079KNJe.png)


### （一）、UDP ###

UDP是一个简单的面向数据报的运输层协议：进程的每个输出操作都正好产生一个UDP数据报，并组装成一份待发送的IP数据报。UDP不提供可靠性：它把应用程序传给IP层的数据发送出去，但是并不保证它们能到达
目的地。（UDP非面向连接：是指通信双方不需要事先建立一条通信线路，而是把每个带有目的地址的包（报文分组）送到线路上，由系统自主选定路线进行传输，就像写信，不管对方有多忙，把信放到邮筒，就与自己无关系了。）

UDP协议首部：

![](http://img.blog.csdn.net/20150408144330303)

（这里不详细解释UDP首部各自段含义）

### （二）、TCP ###

#### 1.TCP概述 ####

尽管TCP和UDP都使用相同的网络层（IP），TCP却向应用层提供与UDP完全不同的服务。TCP提供一种面向连接的、可靠的字节流服务。

面向连接意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。这一过程与打电话很相似，先拨号振铃，等待对方摘机说“喂”，然后才说明是谁（在一个TCP连接中，仅有两方进行批次通信，广播和多播不能用于TCP）。

**I、TCP的服务**

TCP通过下列方式来提供可靠性：

- 应用数据被分割成TCP认为最适合发送的数据块。这和UDP完全不同，应用程序产生的数据报长度将保持不变。由TCP传递给I P的信息单位称为报文段或段（ segment）。
- 当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。
- 当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒。
- TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错， TCP将丢弃这个报文段和不确认收到此报文段（希望发端超时并重发）。
- 既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。如果必要，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层。
- 既然IP数据报会发生重复， TCP的接收端必须丢弃重复的数据。
- TCP还能提供流量控制。TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。

**2.TCP的首部**

![](https://i.imgur.com/djarvxN.png)

（1）端口号[16bit]

我们知道，网络实现的是不同主机的进程间通信。在一个操作系统中，有很多进程，当数据到来时要提交给哪个进程进行处理呢?这就需要用到端口号。
每个TCP段都包含源端和目的端的端口号，用于寻找发端和收端应用进程(源端口号标识了发送主机的进程,目标端口号标识接受方主机的进程)。这两个值加上IP首部中的源端IP地址和目的端IP地址唯一确定一个TCP连接。

(2)序号(发送序号)[32bit]

发送序号用来标识从 TCP源端向 TCP目的端发送的数据字节流，它表示在这个报文段中的第一个数据字节的顺序号。如果将字节流看作在两个应用程序间的单向流动，则TCP用顺序号对每个字节进行计数。序号是 32bit的无符号数，序号到达 2^32－1后又从 0开始。当建立一个新的连接时， SYN标志变1，序号字段包含由这个主机选择的该连接的初始序号 ISN（ Initial Sequence Number）。该主机要发送数据的第一个字节序号为这个ISN加1，因为SYN标志消耗了一个序号。

(3)确认序号[32bit]

确认序号：包含发送确认的一端所期望收到的下一个顺序号。因此，确认序号应当是上次已成功收到数据字节顺序号加 1。只有 ACK标志为 1时确认序号字段才有效。 TCP为应用层提供全双工服务，这意味数据能在两个方向上独立地进行传输。因此，连接的每一端必须保持每个方向上的传输数据顺序号。

（4）偏移Offset[4bit]

这里的偏移实际指的是TCP首部的长度，它用来表明TCP首部中32 bit字的数目，通过它可以知道一个TCP包它的用户数据是从哪里开始的。

（5）Reserved [6bit]

目前没有使用，它的值都为0.（暂时保留）


（6）标志[6bit]

在TCP首部中有6个标志比特。他们中的多个可同时被置为1 。

- URG：紧急指针(urgent pointer)有效
- ACK：确认序号有效
- PSH：指示接收方应该尽快将这个报文段交给应用层而不用等待缓冲区装满
- RST：一般表示断开一个连接。（重建连接）
- SYN：同步序号用来发起一个连接
- FIN：发送端完成发送任务(即断开连接)

（需要注意的是：1.不要将确认序号ack与标志位中的ACK搞混了；2.确认方ack=发起方seq+1，两端配对。）

（7）窗口大小(window)[16bit]

窗口的大小，表示源方法最多能接受的字节数。（TCP的流量控制由连接的每一端通过声明的窗口大小来提供。）

（8）校验和[16bit]

校验和覆盖了整个的TCP报文段:TCP首部和TCP数据。这是一个强制性的字段，一定是由发端计算和存储，并由收端进行验证。

（9）紧急指针[16bit]

只有当URG标志置为1时紧急指针才有效。紧急指针是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。TCP的紧急方式是发送端向另一端发送紧急数据的一种方式。

（10）TCP选项

是可选的.



#### 2.建立连接协议（三次握手） ####

![](https://i.imgur.com/JkI3eCN.png)

TCP是一个面向连接的协议。无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接（三次握手与四次挥手）。


- 1) 请求端（通常称为客户）发送一个SYN段指明客户打算连接的服务器的端口，以及初始序号（ISN，在这个例子中为1415531521）。这个SYN段为报文段1。
- 2) 服务器发回包含服务器的初始序号的SYN报文段（报文段2）作为应答。同时，将确认序号设置为客户的ISN加1以对客户的SYN报文段进行确认。一个SYN将占用一个序号。
- 3) 客户必须将确认序号设置为服务器的ISN加1以对服务器的SYN报文段进行确认（报文段3）。

这三个报文段完成连接的建立。这个过程也称为三次握手（ three-way handshake）。

![](http://www.2cto.com/uploadfile/2013/1022/20131022025346218.png)



- 第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。
- 第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。
- 第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。

下面分析下抓包数据：

![](http://blog.chinaunix.net/attachment/201304/27/26833883_1367053368d41s.png)

前三次是三次握手的过程，可以看到，三次握手确定了双方间包的序号、最大接受数据的大小(window)以及MSS(Maximum Segment Size) —— MSS限制了TCP包携带数据的大小,它的意思就是当应用层向传输层提交数据通过TCP协议进行传输时，如果应用层的数据>MSS就必须分段，分成多个段，逐个的发过去。

后面三次是传送数据的过程，由于数据大小是4096个字节，所以用了三次进行传递(1448 + 1448 + 1200)。

附 —— SYN攻击：

在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，使用如下命令可以让之现行：

	 #netstat -nap | grep SYN_RECV


#### 3.连接终止协议（四次挥手） ####

![](http://www.2cto.com/uploadfile/2013/1022/20131022025350523.png)

 由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。


- 第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。
- 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。
- 第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。
- 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。

抓包数据参考如下：

![](http://blog.chinaunix.net/attachment/201304/27/26833883_136705352281eV.png)


问：为什么建立连接是三次握手，而关闭连接却是四次挥手呢？

答： 这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。





### 二、HTTP与HTTPS ###

![](http://images.cnitblog.com/blog/449064/201503/021956187857562.jpg)


### （一）、认识HTTP ###

HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议（用来定义浏览器与Web服务器之间如何通信以及通信的数据格式）。HTTP（超文本传输协议）协议是一个建立在TCP传输协议之上的属于应用层的面向对象的协议，是因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准。

![](https://gss0.bdstatic.com/7LsWdDW5_xN3otebn9fN2DJv/doc/pic/item/c2cec3fdfc039245bb12838a8e94a4c27c1e258b.jpg)

- HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
- HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。
- HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。

### （二）、HTTP协议报文格式 ###

![](https://i.imgur.com/yM8SWk2.png)

HTTP是基于客户端/服务端（C/S）的架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。

- 一个HTTP"客户端"是一个应用程序（Web浏览器或其他任何客户端），通过连接到服务器达到向服务器发送一个或多个HTTP的请求的目的。
- 一个HTTP"服务器"同样也是一个应用程序（通常是一个Web服务，如Apache Web服务器或IIS服务器等），通过接收客户端的请求并向客户端发送HTTP响应数据。

HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。一旦建立连接后，数据消息就通过类似Internet邮件所使用的格式[RFC5322]和多用途Internet邮件扩展（MIME）[RFC2045]来传送。

#### 1.HTTP请求消息 ####

![](https://i.imgur.com/bBoMEDs.png)

客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据4个部分组成，下图给出了请求报文的一般格式。

![](https://i.imgur.com/nMztFFn.png)

**(1)HTTP请求行**

HTTP请求行包含用于请求的方法，请求URI和HTTP协议版本。请求行以一个方法符开头，以空格分开，后面跟着请求的URI和协议的版本，格式为：

	 Method  Request-URI  HTTP-Version CRLF    

其中，Method表示请求方法，CRLF表示回车和换行（除了作为结尾的CRLF外，不允许出现单独的CR或LF字符）                                                                                                                                                                       

根据HTTP标准，HTTP请求可以使用多种请求方法。

- HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。
- HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。

![](https://i.imgur.com/iaXwdDw.png)


	

-  GET：请求获取Request-URI 所标识的资源；
-  POST：在Request-URI 所标识的资源后附加新的提交数据；
-  HEAD：请求获取由Request-URI所标识的资源的响应消息报头；
-  PUT：请求服务器存储一个资源，并用Request-URI作为其标识；
-  DELETE：请求服务器删除Request——URI所标识的资源；
-  TRACE：请求服务器回送收到的请求信息，主要用于测试或诊断；
-  CONNECT：保留将来使用；
-  OPTIONS：请求查询服务器的性能，或者查询与资源相关的选项和需求。

**（2）消息头**

HTTP请求消息头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息。消息头是一些键值对，一般由w3c定义，通信的双方通过消息头来传递一些特定的含义，比如，浏览器可以发送User-Aget消息头告诉Web服务器浏览器的类型和版本。大部分为自动生成，某些时候自己需要添加消息头，常用的消息头字段如下：

-  Accept：
-  Accept-Charset：
-  Accept-Encoding:
-  Accept-Language:
-  Authorizations:
-  Host:
-  User-Agent:
-  Content-Length:
-  Content-Type：
-  Connection：

**（3）实体内容**

只有当请求方式为post时，实体内容才会有数据（即请求参数）。




#### 2.HTTP响应消息 ####

![](https://i.imgur.com/d70vBVy.png)

HTTP响应消息（HttpResponse）也是由三个部分组成，分别是：状态行、消息报头、响应正文。

**（1）状态行**

状态行包含表明响应结果的状态码，原因短语和HTTP版本。状态行的格式为：

	HTTP-Version  Status-Code  Reason-Phrase CRLF

其中HTTP-Version表示服务器HTTP协议的版本，Status-Code表示服务器返回的响应状态代码。状态代码由三位数字组成，第一个数字定义了响应的类别，它有5种可能的取值：

-  1xx： 指示信息。表示请求已接收，继续处理；
-  2xx： 成功。表示请求已被成功接收、理解、接受；
-  3xx： 重定向。要完成请求必须进行更进一步的操作；
-  4xx： 客户端错误。请求有语法错误或请求无法实现；
-  5xx： 服务器错误。服务器未能处理请求。    

![](http://images2015.cnblogs.com/blog/1030566/201611/1030566-20161113202308702-1568027245.png)

 当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。

![](https://i.imgur.com/3OaeZH5.png)
![](https://i.imgur.com/5eJkSow.png)

**（2）消息头**

![](https://i.imgur.com/ADegtDw.png)

（其中，Content-Type，内容类型，一般是指网页中存在的Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件，这就是经常看到一些Asp网页点击的结果却是下载到的一个文件或一张图片的原因。）


**（3）实体内容**

实体内容：程序处理的结果


**附 —— 首部字段（消息头）**

HTTP首部字段根据实际用途被分为以下4中类型：

- 通用首部字段（General Header Fields）：请求报文和响应报文双方都会使用的首部。

![](https://i.imgur.com/GCFORRN.png)

- 请求首部字段（Request Header Fields）：从客户端向服务器发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。

![](https://i.imgur.com/RlnrWz3.png)

- 响应首部字段（Response Header Fields）：从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。

![](https://i.imgur.com/rcUckeA.png)
![](https://i.imgur.com/xNTxtbE.png)

- 实体首部字段（Entity Header Fields）：针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体相关的信息。

![](https://i.imgur.com/hHkUyu4.png)

#### （四）、通信数据转发程序：代理、网关、隧道 ####

HTTP通信时，除客户端和服务端以外，还有一些用于通信数据转发的应用程序，例如代理、网关和隧道。它们可以配合服务器工作。这些应用程序和服务器可以将请求转发给通信线路上的下一站服务器，并且能接收从那台服务器发送的响应在转发给客户端。



**1.代理**

代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。

- 缓存代理：代理转发响应时，缓存代理(Caching Proxy)会预先将资源的副本(缓存)保存在代理服务器上。当代理再次接收到对相同资源的请求时，就可以不从源服务器哪里获取资源，而是将之前缓存的资源作为响应返回。
- 透明代理：转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理(Transparent Proxy).反之，对报文内容进行加工的代理被称为非透明代理。

**2.网关**

网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会觉察，自己的通信目标是一个网关。


**3.隧道**

隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。隧道的目的是确保客户端能与服务器进行安全的通信。隧道本身不会去解析HTTP请求，也就是说，请求保持原样中转给之后的服务器。隧道会在通信双方断开连接时结束。

#### （五）、确保web安全的HTTPS ####

**1.HTTP缺点**

- 通信使用明文（不加密），内容可能会被窃听
- 不验证通信方的身份，因此有可能遭遇伪装
- 无法证明报文的完整性，所以有可能已遭篡改


**2.HTTPS**

为了统一解决上述这些问题，需要在HTTP上再加上加密处理和认证等机制。我们把添加了加密及认证机制的HTTPS称为HTTPS（HTTP所用的端口号是80，HTTPS所用的端口号是443）—— HTTPS将HTTP协议与一组强大的对称、非对称和基于证书的机密技术结合在一起。（HTTPS = HTTP + 通信加密 + 证书 + 完整性保护）.

![](http://www.blogjava.net/images/blogjava_net/amigoxie/40799/o_http%e5%8d%8f%e8%ae%ae%e5%ad%a6%e4%b9%a0%e5%92%8c%e6%80%bb%e7%bb%93%e7%b3%bb%e5%88%97-3-4.jpg)

（1）加密

通过SSL（安全套接层）或TLS（安全传输协议）组合使用，加密HTTP的通信内容。（HTTPS是采用混合加密机制，共享秘钥+公开秘钥的方式实现加密）

（2）认证

![](http://images2015.cnblogs.com/blog/1030566/201611/1030566-20161113221159420-1180937909.png)

- BASIC认证（基本认证）
- DIGEST认证（摘要认证）
- SSL客户端认证
- FormBase认证（基于表单认证）



#### （六）、WEB安全 ####

TODO：待续




### 三、BIO、NIO、AIO ###

#### 1.同步阻塞IO（JAVA BIO,JAVA block IO） ####

同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。 

使用场景：BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。 

**（1）传统的BIO**

网络编程的基本模型是C/S模型，即两个进程间的通信。服务端提供IP和监听端口，客户端通过连接操作向服务端监听的地址发起连接请求，通过三次握手连接，如果连接成功建立，双方就可以通过套接字进行通信。传统的同步阻塞模型开发中，ServerSocket负责绑定IP地址，启动监听端口；Socket负责发起连接操作。连接成功后，双方通过输入和输出流进行同步阻塞式通信。 


![](http://blog.anxpp.com/usr/uploads/2016/05/549520916.png)

如上图所示，采用BIO通信模型的服务端，通常由一个独立的Acceptor线程负责监听客户端的连接，它接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理。处理完成后，通过输出流返回应答给客户端，线程销毁。即典型的一请求一应答通信模型。该模型最大的问题就是缺乏弹性伸缩能力，当客户端并发访问量增加后，服务端的线程个数和客户端并发访问数呈1:1的正比关系，Java中的线程也是比较宝贵的系统资源，线程数量快速膨胀后，系统的性能将急剧下降，随着访问量的继续增大，系统最终就死-掉-了。

**（2）伪异步IO**

为了改进传统BIO这种一连接一线程的模型，我们可以使用线程池来管理这些线程，实现1个或多个线程处理N个客户端的模型（但是底层还是使用的同步阻塞I/O），通常被称为“伪异步I/O模型“。

![](http://blog.anxpp.com/usr/uploads/2016/05/614169023.png)

正因为限制了线程数量，如果发生大量并发请求，超过最大数量的线程就只能等待，直到线程池中的有空闲的线程可以被复用。而对Socket的输入流并行读取时，会一直阻塞，直到发生：

- 有数据可读
- 可用数据已经读取完毕
- 发生空指针或I/O异常

所以在读取数据较慢时（比如数据量大、网络传输慢等），大量并发的情况下，其他接入的消息，只能一直等待，这就是最大的弊端。

#### 2.非阻塞IO（JAVA NIO，JAVA Non-block IO） ####


NIO我们一般认为是New I/O（也是官方的叫法），因为它是相对于老的I/O类库新增的，做了很大的改变。但更多人称之为Non-block I/O，即非阻塞I/O，因为这样叫，更能体现它的特点。服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。（笔者注：其实JDK）

使用场景：NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。 


#### 3.异步非阻塞IO（JAVA AIO，也称NIO2.0） ####

在此种模式下，用户进程只需要发起一个IO操作然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的IO读写操作，因为真正的IO读取或者写入操作已经由内核完成了。    

使用场景：AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。 



    

    

    












