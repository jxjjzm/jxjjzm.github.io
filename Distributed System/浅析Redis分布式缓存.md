### 浅析Redis分布式缓存 ###
***
### 一、Redis缓存穿透 ###



### 二、Redis缓存并发 ###




### 三、Redis缓存失效 ###






四、Redis上踩过的一些坑

(部分内容转载自：[Redis上踩过的一些坑-美团](http://blog.csdn.net/chenleixing/article/details/50530419)、[那些年使用缓存踩过的坑](https://mp.weixin.qq.com/s?__biz=MzI3OTUwMjM4MA%3D%3D&mid=2247483718&idx=1&sn=3324abf6b2a3245e330b35213ee922a5&chksm=eb478a05dc300313355f4e437ec701b58356c4aa19ad36c46c4031216dab3016e016bda8afee))


1.shop_img 缓存穿透


mysql select 7k ------> mysql global log ------> 前置redis
------> 加了还有 -----> 空数据没缓存  ------> 仍然有问题 ------> 漏了一个地方




2.redis内存占用飙升
redis-cluster某个分片内存飙升，明显比其他分片高很多，而且持续增长。并且主从的内存使用量并不一致。

![](http://dl2.iteye.com/upload/attachment/0112/8746/c1763302-3ce3-3aa1-ab06-b79c9a5568f9.jpg)

分析可能原因：
（1）redis-cluster的bug （这个应该不存在）
（2）客户端的hash(key)有问题，造成分配不均。（redis使用的是crc16, 不会出现这么不均的情况）
（3）存在个别大的key-value: 例如一个包含了几百万数据set数据结构（这个有可能）
（4）主从复制出现了问题。
（5）其他..................



3.周期性出现connect timeout

 (1). 网络原因：比如是否存在跨机房、网络割接等等。
 (2). 慢查询，因为redis是单线程，如果有慢查询的话，会阻塞住之后的操作。 
 (3). value值过大？比如value几十兆，当然这种情况比较少，其实也可以看做是慢查询的一种
 (4). aof重写/rdb fork发生？瞬间会堵一下Redis服务器。
 (5). 其他..................


案例4.缓存和DB的同步更新不在同一个事务里并且没有重试补偿机制

了减少系统间的依赖，不同系统的数据更新往往不放在同一个事务里，采用MQ来进行通信。大家可以看下图，后台系统CRM更新产品数据到DB，Product系统收到异步消息通知后，更新最新数据到缓存。这是一个最常见的缓存应用场景，我相信很多团队都是这样用的。在这个Case里容易出现的问题在于，如果批处理任务收到消息后服务crash掉了，缓存没有正常更新，就出现了与DB的数据不同步，前端系统一直不能读到最新数据，导致业务异常。

![](http://mmbiz.qpic.cn/mmbiz_png/db7D8z7FCyDZViaOiaicw63St1ia5oThHrfrqPd9e0fJgeu4iab3bs4mSIbw61sfbibvbgdl2IhDcjzpbviaIiaIF5VpcA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)



解决方案：

1.  失败消息一定要建立一定时间间隔的重试机制
2.  系统要有缓存更新的报警机制，方便更新失败或者重试超时后，可以人工介入进行补偿。


案例5. 同一数据被1个以上的服务执行写操作，其中一个服务的缓存数据没有版本控制

这也是两个不同服务更新数据过程中很常见的情况，见下图，CRM系统更新了某个用户的Profile, 保存更新数据库后，通过MQ通知用户系统更新缓存，由于是异步更新延迟，在缓存更新前，用户系统收到前端的指令，读取了当前缓存里的用户数据，做了修改，并更新到DB中。出现的结果就是数据库里的CRM的更新被错误覆盖。


![](http://mmbiz.qpic.cn/mmbiz_png/db7D8z7FCyDZViaOiaicw63St1ia5oThHrfr9lGCibrUCjDtLiahMr36vDqpHibZm0V4AP3ib8JcHmfWia4lLnkfov2I1zQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)



解决方案：缓存里的数据有一个标志位可以作为更新数据库数据的依据（Update_time or Version）, 如果缓存里数据时间与数据库时间不能匹配，意味着另外一个服务更新了该数据，那么就先从DB里读取最新数据版本，然后在新版本上提交数据。




案例3. 并发查询缓存中同一数据，如果缓存没命中，导致DB瞬时被打爆

做促销活动的时候，存在大量用户的并发访问某一个特定商品，该商品数据缓存失效，或者做了数据更改，但是对应缓存还没有更新，那么所有这些访问将同时直接被作用到DB上。

![](http://mmbiz.qpic.cn/mmbiz_png/db7D8z7FCyDZViaOiaicw63St1ia5oThHrfreh3hWzMNerkicCvP5dXCwCxp3FQmANvZmTTDHdS5C9O4SeUlFsdthicQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)


解决方案：做一个计数器或者锁（没有特别复杂逻辑的话，可以直接用HashMap），如果发现某个KEY缓存没有命中，那么在计数器+1, 然后访问数据库，拿到结果更新缓存，清理掉计数器中的key。 在这个过程中，如果有第二个线程或者更多的线程需要访问这个KEY时，发现计数器的值>1 或者被加锁, 那么wait, 直到计数器清理掉，当然，这个技术器阈值是可以在配置文件里配置的，不一定是1。



案例4， 缓存没有设置默认值，被攻击，缓存一直保持在被“穿透”状态
这个情况，和案例3比较类似，都是缓存无法命中，但不一样的地方在于，数据的KEY值是无法控制的，所以没法简单的用计数器和锁来处理, 比方，被人为攻击，制造的大量的无效userID访问。

解决方案：所有没有在缓存的KEY，全部分配一个默认VALUE “UNKOWN-KEY” ，具体是什么情况下，将默认值分配给没有命中的KEY， 这个可以根据自己的业务系统来定，比方说，可以根据特定的IP段，或者没有命中的总次数等，然后我们就可以决定是否继续访问DB还是直接返回默认值给前端，拒绝本次数据访问。这种做法的核心在于，每次数据访问，都会有缓存结果返回，根据系统的情况来决定是否要进一步访问DB。

总结，今天列举的这几个案例，归纳起来，可以总结为以下几点：
1. 保证缓存同步
2. 减少缓存并发
3. 杜绝缓存穿透


















