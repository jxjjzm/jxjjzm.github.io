### Zookeeper概述篇 ###
***
### 一、初始Zookeeper ###

ZooKeeper是一个开放源代码的***分布式应用程序协调服务***，由知名互联网公司雅虎创建，是Google Chubby的开源实现，是Hadoop和Hbase的重要组件。ZooKeeper的设计目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。它包含一个简单的原语集，分布式应用程序可以基于它实现诸如***数据发布/订阅、负载均衡、配置服务、命名服务、分布式协调/通知、集群管理、Master选举、分布式锁和分布式队列等功能***。

***问：为什么使用Zookeeper？***

***答：***

- ***首先***，随着分布式架构的出现，越来越多的分布式应用会面临数据一致性、协作与交互困难等问题——1）大部分分布式应用需要一个主控、协调器或控制器来管理物理分布的子进程（如资源、任务分配等）；2）目前，大部分应用需要开发私有的协调程序，缺乏一个通用的机制；3）协调程序的反复编写浪费，且难以形成通用、伸缩性好的协调器；4）ZooKeeper：提供通用的分布式锁服务，用以协调分布式应用（Zookeeper无论从性能、易用性还是稳定性上来说，都已经达到了一个工业级产品的标准）。
- ***其次***，ZooKeeper是开放源代码的；
- ***另外***，ZooKeeper是免费的；
- ***最后***，ZooKeeper已经得到了广泛的应用——诸如Hadoop、HBase、Storm和Solr等越来越多的大型分布式项目都已经将ZooKeeper作为其核心组件，用于分布式协调。



#### 1、Zookeeper的设计目标 ####

Zookeeper致力于提供一个高性能、高可用、且具有严格的顺序访问控制能力（主要是写操作的严格顺序性）的分布式协调服务.高性能使得Zookeeper能够应用于那些对系统吞吐有明确要求的大型分布式系统中，高可用使得分布式的单点问题得到了很好的解决，而严格的顺序访问控制使得客户端能够基于Zookeeper实现一些复杂的同步原语。



- 目标一：简单的数据模型

ZooKeeper使得分布式程序能够通过一个共享的、树型结构的名字空间开进行相互协调。这里所说的树型结构的名字空间，是指Zookeeper服务器内存中的一个数据模型，其由一系列被称为ZNode的数据节点组成，总的来说，其数据模型类似于一个文件系统，而ZNode之间的层级关系就像文件系统的目录结构一样。不过和传统的磁盘文件系统不同的是，Zookeeper将全量数据存储在内存中，以此来实现提高服务器吞吐、减少延迟的目的。（Zookeeper的数据模型将会在《ZooKeeper原理篇》做详细阐述）

![](https://i.imgur.com/UsQr5cP.png)

- 目标二：可以构建集群

一个Zookeeper集群通常由一组机器组成，一般3～5台机器就可以组成一个可用的Zookeeper集群了，组成ZooKeeper集群的每台机器都会在内存中维护当前的服务器状态，并且每台机器之间都互相保持着通信。值得一提的是，只要集群中存在超过一半的机器能够正常工作，那么整个集群就能够正常对外服务。（（Zookeeper集群也将会在《ZooKeeper原理篇》做详细阐述））

![](https://i.imgur.com/7EdOwQt.png)


- 目标三：顺序访问

对于来自客户端的每个更新请求，Zookeeper都会分配一个全局唯一的递增编号，这个编号反映了所有事务操作的先后顺序，应用程序可以使用Zookeeper的这个特性来实现更高层次的同步原语。



- 目标四：高性能

由于Zookeeper将全量数据存储在内存中，并直接服务于客户端的所有非事务请求，因此它尤其适用于以读操作为主的应用场景。


#### 2、Zookeeper的基本概念 ####

本篇博文的初衷虽然只是针对Zookeeper作一个入门性的基本介绍，但是以下几个核心概念不得不提到，因为这些概念贯穿于本系列博文之后对Zookeeper更深入的讲解。（将会在《ZooKeeper原理篇》做详细阐述）

- ***集群角色***：

通常在分布式系统中，构成一个集群的每一台机器都有自己的角色，最典型的集群模式就是Master/Slave模式（主备模式）。在这种模式中，我们把能够处理所有写操作的机器称为Master机器，把所有通过异步复制方式获取最新数据，并提供读服务的机器为Slave机器。而在ZooKeeper中，这些概念被颠覆了。它没有沿用传统的Master/Slave概念，而是引用了Leader、Follower和Observer三种角色。ZooKeeper集群中的所有机器通过一个Leader选举过程来选定一台被称为“Leader”的机器，Leader服务器为客户端提供读和写服务。除Leader外，其他机器包括Follower和Observer。Follwer和Observer都能够提供读服务，唯一的区别在于，Observer机器不参与Leader选举过程，也不参与写操作的“过半写成功”策略，因此Observer可以在不影响写性能的情况下提升集群的读性能。




- ***会话Session***：

Session是指客户端会话，在讲解会话之前，我们首先来了解一下客户端连接。在Zookeeper中，一个客户端连接是指客户端和服务端之间的一个TCP长连接。Zookeeper对外的服务端口默认是2181，客户端启动的时候，首先会与服务端建立一个TCP连接，从第一次连接建立开始，客户端会话的生命周期也开始了，通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向Zookeeper服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的Watch事件通知。



- ***数据节点Znode***:

在Zookeeper中，“节点”分为两类，第一类指构成集群的机器，称为机器节点，第二类是指数据模型中的数据单元，称为数据节点-Znode，Zookeeper将所有数据存储在内存中，数据模型是一棵树，由斜杠/进行分割的路径，就是一个ZNode，如/foo/path1，每个ZNode都会保存自己的数据内存，同时还会保存一些列属性信息。ZNode分为持久节点和临时节点两类，持久节点是指一旦这个ZNode被创建了，除非主动进行ZNode的移除操作，否则这个ZNode将一直保存在Zookeeper上，而临时节点的生命周期和客户端会话绑定，一旦客户端会话失效，那么这个客户端创建的所有临时节点都会被移除。另外，Zookeeper还允许用户为每个节点添加一个特殊的属性：SEQUENTIAL。一旦节点被标记上这个属性，那么在这个节点被创建的时候，Zookeeper会自动在其节点后面追加一个整形数字，其是由父节点维护的自增数字。


- ***版本***:

在Zookeeper中，对于每个ZNode，Zookeeper都会为其维护一个叫作Stat的数据结构，Stat记录了这个ZNode的三个数据版本，分别是version（当前ZNode的版本）、cversion（当前ZNode子节点的版本）、aversion（当前ZNode的ACL版本）。


- ***Watcher***:

Watcher（事件监听器），是Zookeeper中的一个很重要的特性。Zookeeper允许用户在指定节点上注册一些Watcher，并且在一些特定事件触发的时候，Zookeeper服务端会将事件通知到感兴趣的客户端上去，该机制是Zookeeper实现分布式协调服务的重要特性。



- ***ACL***:

Zookeeper采用ACL（Access Control Lists）策略来进行权限控制，类似于UNIX文件系统的权限控制。Zookeeper定义了如下5种权限：

		  · CREATE：创建子节点的权限。
	
	　　　　· READ：获取节点数据和子节点列表的权限。
	
	　　　　· WRITE：更新节点数据的权限。
	
	　　　　· DELETE：删除子节点的权限。
	
	　　　　· ADMIN：设置节点ACL的权限。

（其中尤其需要注意的是，CREATE和DELETE这两种权限都是针对子节点的权限控制。）

#### 3、Zookeeper优点（特点） ####

ZooKeeper可以保证如下分布式一致性特性：


- ***顺序一致性***：按照客户端发送请求的顺序更新数据，包括全局有序和偏序两种——全局有序是指如果在一台服务器上消息a在消息b前发布，则在所有Server上消息a都将在消息b前被发布；偏序是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面。***（保证来自一个用户的所有请求会被按顺序处理）***


- ***原子性***：所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群所有机器都成功应用了某一个事务，要么都没有应用，一定不会出现集群中部分机器应用了该事务，而另外一部分没有应用的情况。


- ***单一视图（Single System Image）***:无论客户端连接的是哪个zookeeper服务器，其看到的服务端数据模型都是一致的。***（保证所有用户得到的数据是一致的）***



- ***可靠性***：一旦服务端成功地应用了一个事务，并完成对客户端的响应，那么该事务所引起的服务端状态变更将会被一直保留下来，除非有另一个事务又对其进行了变更。


- ***实时性***：通常人们看到实时性的第一反应是，一旦一个事务被成功应用，那么客户端能够立即从服务端上读取到这个事务变更后的最新数据状态。这里需要注意的是Zookeeper仅仅保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。但由于网络延时等原因，Zookeeper不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用sync()接口。***（当用户正在查看的数据被修改时，保证用户会被即时通知）***


- ***等待无关***：慢的或者失效的client不得干预快速的client的请求，使得每个client都能有效的等待。 


### 二、Zookeeper的ZAB协议 ###

在正式介绍Zookeeper的ZAB协议之前有必要先介绍下Paxos算法，因为ZAB协议是Paxos的改进或简化。

#### （一）、Paxos算法 ####

Paxos算法是莱斯利·兰伯特（英语：Leslie Lamport，LaTeX中的「La」）于1990年提出的一种基于消息传递且具有高度容错特性的一致性算法。其需要解决的问题就是如何在一个可能发生异常的分布式系统中，快速且正确地在集群内部对某个数据的值达成一致，并且保证不论发生以上任何异常，都不会破坏整个系统的一致性。

![](http://upload-images.jianshu.io/upload_images/1752522-d2136179b456e13e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&_=6253479)

***Paxos一共四个角色：***

- Client：产生议题者
- Proposer ：提议者——提出提案，提案信息包括提案编号和提议的value;
- Acceptor：决策者——收到提案后可以接受(accept)提案；
- Learner：最终决策学习者，也就是执行者——只能"学习"被批准的提案;

（Proposer拿着Client的议题去向Acceptor提议，让Acceptor来决策 ------> Proposer提出议题，Acceptor初步接受或者Acceptor初步不接受 ------> Acceptor初步接受则Proposer再次向Acceptor确认是否最终接受 ------> Acceptor最终接受或者Acceptor最终不接受 ------> Learner最终学习的目标是向所有Acceptor学习，如果有多数派个Acceptor最终接受了某提议，那就得到了最终的结果，算法的目的就达到了。）



***Paxos算法保证一致性的三个基本语义以及演化而来的四个约束：***

三个基本语义：

- 1）、决议(value)只有在被proposers提出后才能被批准(未经批准的决议称为"提案(proposal)");
- 2）、在一次Paxos算法的执行实例中，只批准(chosen)一个value;
- 3）、learners只能获得被批准(chosen)的value;

四个约束：

- P1:一个acceptor必须接受(accept)第一次收到的提案;
- P2a:一旦一个具有value v的提案被批准(chosen)，那么之后任何acceptor 再次接受(accept)的提案必须具有value v;
- P2b:一旦一个具有value v的提案被批准(chosen)，那么以后任何 proposer 提出的提案必须具有value v;
- P2c:如果一个编号为n的提案具有value v，那么存在一个多数派，要么他们中所有人都没有接受(accept)编号小于n的任何提案，要么他们已经接受(accpet)的所有编号小于n的提案中编号最大的那个提案具有value v;


***paxos算法描述：***

![](http://upload-images.jianshu.io/upload_images/1752522-44c5a422f917bfc5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&_=6253479)

阶段一：

① proposer选择一个提案编号Mn，然后向acceptor的某个超过半数的子集成员发送编号为Mn的prepare请求。

② 如果一个acceptor收到一个编号为Mn的prepare请求，且编号Mn大于该acceptor已经响应的所有prepare请求的编号，那么它就会将它已经批准过的最大编号的提案作为响应反馈给proposer，同时该acceptor会承诺不会再批准任何编号小于Mn的提案。

（举个例子来说，假定一个Acceptor已经响应过的所有请求对应的提案编号分别为1、2、...、5和7，那么该Acceptor在接收到一个编号为8的Prepare请求后，就会将编号为7的提案作为响应反馈给Proposer。）

阶段二：

① 如果proposer收到来自半数以上的acceptor对于其发出的编号为Mn的prepare请求的响应，那么它就会发送一个针对[Mn,Vn]提案的accept请求给acceptor，注意，Vn的值就是收到的响应中编号最大的提案的值，如果响应中不包含任何提案，那么它就是任意值。

② 如果acceptor收到这个针对[Mn,Vn]提案的accept请求，只要该accept尚未对编号大于Mn的prepare请求作出响应，它就可以接受这个提案。



***附录 —— 通过选取主Proposer保证算法的活性***

根据前面的内容讲解，我们已经基本上了解了Paxos算法的核心逻辑。下面我们再来看Paxos算法在实际运作过程中的一些细节。假设存在这样一种极端情况，有两个Proposer依次提出了一些列编号递增的议案，但是最终都无法被选定，具体流程如下：

![](http://upload-images.jianshu.io/upload_images/1752522-0fab48ed2bdf358a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&_=6253479)

proposer1提出了一个编号为M1的提案，然后完成了上述阶段一的流程，但与此同时，另外一个proposer2提出了一个编号为M2（M2>M1）的提案，同样也完成了阶段一的流程，于是acceptor已经承诺不再接受编号小于M2的提案，因此，当proposer1进入阶段二时，其发出的accept请求将被acceptor忽略，于是proposer1又再次进入阶段一并提出了一个编号为M3（M3>M2）的提案，而这又导致proposer2在第二阶段的accept请求被忽略，以次类推，提议的确定过程将陷入死循环。如图所示：

![](https://i.imgur.com/JfiodU2.png)


为了保证Paxos算法流程的可持续性，以避免陷入上述提到的“死循环”，就必须选择一个主Proposer，并规定只有主Proposer才能提出议案。这样一来，只要主Proposer和过半的Acceptor能够正常进行网络通信，那么但凡主Proposer提出一个编号更高的提案，该提案终将会被批准。当然，如果Proposer发现当前算法流程中已经有一个编号更大的提案被提出或正式接受批准，那么它会丢弃当前这个编号较小的提案，并最终能够选出一个编号足够大的提案。因此，如果系统中有足够多的组件（包括Proposer、Acceptor和其他网络通信组件）能够正常工作，那么通过选择一个主Proposer，整套Paxos算法流程就能够保持活性。



***提案的获取：***

前面我们已经介绍了如何来选定一个提案，下面我们再来看看如何让Learner获取提案，大体可以有以下几种方案：

![](http://upload-images.jianshu.io/upload_images/1752522-0fab48ed2bdf358a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&_=6253479)

- ① 一旦acceptor接受了一个提议，就将该提议发送给所有的learner，通信开销很大。
- ② 让所有的acceptor将它们对提议的接受情况，统一发送给一个特定的learner（主learner），当该learner被通知一个提议已经被确定时，它就负责通知其他的learner。主learner可能会出现单点故障。
- ③ 将主learner范围扩大至一个特定的learner集合，该集合中的每个learner都可以在一个提议被选定后通知所有其他的learner，集合learner越多，越可靠，但是通信开销越大。


#### （二）、ZAB协议 ####

**1.ZAB协议**

在深入了解Zookeeper之前，相信很多读者都会认为Zookeeper就是Paxos算法的一个实现。但事实上，Zookeeper并没有完全采用Paxos算法，而是使用了一种称为Zookeeper Atomic Broadcast（ZAB，Zookeeper原子消息广播协议）的协议作为其数据一致性的核心算法。ZAB协议是为分布式协调服务Zookeeper专门设计的一种支持崩溃恢复的原子广播协议。




- Zookeeper依赖ZAB协议来实现分布式数据的一致性，基于该协议，***Zookeeper实现了一种主备模式的系统架构来保持集群中各副本之间的数据的一致性***，具体的，Zookeeper使用一个单一的主进程来接收并处理客户端的所有事务请求，并采用ZAB的原子广播协议，将服务器数据的状态变更以事务Proposal的形式广播到所有的副本进程上去。***ZAB协议的这个主备模型架构保证了同一时刻集群中只能够有一个主进程来广播服务器的状态变更，因此能够很好地处理客户端大量的并发请求***。



- 另一方面，考虑到在分布式环境中，顺序执行的一些状态变更其前后会存在一定的依赖关系，有些状态变更必须依赖于比它早生成的那些状态变更。这样的依赖关系也对ZAB协议提出了一个要求：***ZAB协议必须能够保证一个全局的变更序列被顺序应用***。



- 最后，考虑到主进程在任何时候都有可能出现崩溃退出或重启现象，因此，***ZAB协议还需要做到在当前主进程出现上述异常情况的时候，依旧能够正常工作***。



***ZAB协议的核心***是定义了对于那些会改变Zookeeper服务器数据状态的事务请求的处理方式，即：所有事务请求必须由一个全局唯一的服务器来协调处理，这样的服务器被称为Leader服务器，而余下的其他服务器则称为Follower服务器。Leader服务器负责将一个客户端事务请求转化成一个事务Proposal（提议），并将该Proposal分发给集群中所有的Follower服务器，之后Leader服务器需要等待所有Follower服务器的反馈，一旦超过半数的Follower服务器进行了正确的反馈后，那么Leader就会再次向所有的Follower服务器分发Commit消息，要求其将前一个Proposal进行提交。


**2.ZAB协议介绍**

ZAB协议包括两种基本的模式：分别是***崩溃恢复***和***消息广播***。



- 当整个服务框架启动过程中或Leader服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB协议就会进入恢复模式并选举产生新的Leader服务器。当选举产生了新的Leader服务器，同时集群中已经有过半的机器与该Leader服务器完成了状态同步之后，ZAB协议就会退出恢复模式。（其中，所谓的状态同步是指数据同步，用来保证集群中存在过半的机器能够和Leader服务器的数据状态保持一致。）



- 当集群中已经有过半的Follower服务器完成了和Leader服务器的状态同步，那么整个服务框架就可以进入消息广播模式了，当一台同样遵守ZAB协议的服务器启动后加入到集群中时，如果此时集群中已经存在一个Leader服务器在负责进行消息广播，那么新加入的服务器就会自觉地进入数据恢复模式：找到Leader所在的服务器，并与其进行数据同步，然后一起参与到消息广播流程中去。Zookeeper只允许唯一的一个Leader服务器来进行事务请求的处理，Leader服务器在接收到客户端的事务请求后，会生成对应的事务提议并发起一轮广播协议，而如果集群中的其他机器接收到客户端的事务请求，那么这些非Leader服务器会首先将这个事务请求转发给Leader服务器。

　　

- 当Leader服务器出现崩溃退出或者机器重启、亦或是集群中已经不存在过半的服务器与该Leader服务器保持正常通信时，那么在重新开始新的一轮的原子广播事务操作之前，所有进程首先会使用崩溃恢复协议来使彼此到达一致状态，于是整个ZAB流程就会从消息广播模式进入到崩溃恢复模式。一个机器要成为新的Leader，必须获得过半进程的支持，同时由于每个进程都有可能会崩溃，因此，ZAB协议运行过程中，前后会出现多个Leader，并且每个进程也有可能会多次成为Leader，进入崩溃恢复模式后，只要集群中存在过半的服务器能够彼此进行正常通信，那么就可以产生一个新的Leader并再次进入消息广播模式。

（1）消息广播

ZAB协议的消息广播过程使用原子广播协议，类似于一个二阶段提交过程，针对客户端的事务请求，Leader服务器会为其生成对应的事务Proposal，并将其发送给集群中其余所有的机器，然后再分别收集各自的选票，最后进行事务提交。

![](http://images2015.cnblogs.com/blog/616953/201610/616953-20161031193240018-708457999.png)

在ZAB的二阶段提交过程中，移除了中断逻辑，所有的Follower服务器要么正常反馈Leader提出的事务Proposal，要么就抛弃Leader服务器，同时，ZAB协议将二阶段提交中的中断逻辑移除意味着我们可以在过半的Follower服务器已经反馈Ack之后就开始提交事务Proposal，而不需要等待集群中所有的Follower服务器都反馈响应，但是，在这种简化的二阶段提交模型下，无法处理Leader服务器崩溃退出而带来的数据不一致问题，因此ZAB采用了崩溃恢复模式来解决此问题，另外，整个消息广播协议是基于具有FIFO特性的TCP协议来进行网络通信的，因此能够很容易保证消息广播过程中消息接受与发送的顺序性。在整个消息广播过程中，Leader服务器会为每个事务请求生成对应的Proposal来进行广播，并且在广播事务Proposal之前，Leader服务器会首先为这个事务Proposal分配一个全局单调递增的唯一ID，称之为事务ID（ZXID），由于ZAB协议需要保证每个消息严格的因果关系，因此必须将每一个事务Proposal按照其ZXID的先后顺序来进行排序和处理。

具体的，在消息广播过程中，Leader服务器会为每一个Follower服务器都各自分配一个单独的队列，然后将需要广播的事务Proposal依次放入这些队列中去，并且根据FIFO策略进行消息发送。每一个Follower服务器在接收到这个事务Proposal之后，都会首先将其以事务日志的形式写入到本地磁盘中去，并且在成功写入后反馈给Leader服务器一个ACK响应。当Leader服务器接收到超过半数Follower的ACK响应后，就会广播一个Commit消息给所有的Follower服务器以通知其进行事务提交，同时leader自身也会完成对事务的提交，而每一个Follower服务器在接收到Commit消息后，也会完成对事务的提交。

（2）崩溃恢复

在Leader服务器出现崩溃，或者由于网络原因导致Leader服务器失去了与过半Follower的联系，那么就会进入崩溃恢复模式，在ZAB协议中，为了保证程序的正确运行，整个恢复过程结束后需要选举出一个新的Leader服务器，因此，ZAB协议需要一个高效且可靠的Leader选举算法，从而保证能够快速地选举出新的Leader，同时，Leader选举算法不仅仅需要让Leader自身知道已经被选举为Leader，同时还需要让集群中的所有其他机器也能够快速地感知到选举产生的新的Leader服务器。


（3）基本特性



- I、ZAB协议规定了如果一个事务Proposal在一台机器上被处理成功，那么应该在所有的机器上都被处理成功，哪怕机器出现故障崩溃。***ZAB协议需要确保那些已经在Leader服务器上提交的事务最终被所有服务器都提交。***


![](http://images2015.cnblogs.com/blog/616953/201610/616953-20161031195828690-138896834.png)

如上图所示，假设一个事务在Leader服务器上被提交了，并且已经得到了过半Follower服务器的Ack反馈，但是在它Commit消息发送给所有Follower机器之前，Leader服务挂了？------> 在集群正常运行过程中的某一个时刻，Server1是Leader服务器，其先后广播了P1、P2、C1、P3、C2（C2是Commit Of Proposal2的缩写），其中，当Leader服务器发出C2后就立即崩溃退出了，针对这种情况，ZAB协议就需要确保事务Proposal2最终能够在所有的服务器上都被提交成功，否则将出现不一致。



- II、***ZAB协议需要确保丢弃那些只在Leader服务器上被提出的事务。***如果在崩溃恢复过程中出现一个需要被丢弃的提议，那么在崩溃恢复结束后需要跳过该事务Proposal。

![](http://images2015.cnblogs.com/blog/616953/201610/616953-20161031200533846-1367154177.png)

如上图所示，假设初始的Leader服务器Server1在提出一个事务Proposal3之后就崩溃退出了，从而导致集群中的其他服务器都没有收到这个事务Proposal，于是，当Server1恢复过来再次加入到集群中的时候，ZAB协议需要确保丢弃Proposal3这个事务。



结合上面提到的这两个崩溃恢复过程中需要处理的特殊情况，就决定ZAB协议必须设计这样一个Leader选举算法：能够确保提交已经被Leader提交的事务Proposal，同时丢弃已经被跳过的事务Proposal。针对这个要求，如果让Leader选举算法能够保证新选举出来的Leader服务器拥有集群中所有机器最高编号（ZXID最大）的事务Proposal，那么就可以保证这个新选举出来的Leader一定具有所有已经提交的提案。更为重要的是如果让具有最高编号事务的Proposal机器成为Leader，就可以省去Leader服务器检查Proposal的提交和丢弃工作的这一步操作了。




（4）数据同步

完成Leader选举后，在正式开始工作（即接收客户端的事务请求，然后提出新的提案）前，Leader服务器首先会确认事务日志中的所有Proposal是否都已经被集群中的过半机器提交了，即是否完成了数据同步。

ZAB协议的数据同步过程：



- 所有正常运行的服务器，要么成为Leader，要么成为Follower并和Leader保持同步。Leader服务器需要确保所有的Follower服务器都能够接收到每一条事务Proposal，并且能够正确地将所有已经提交了的事务Proposal应用到内存数据库中。具体的，Leader服务器会为每个Follower服务器维护一个队列，并将那些没有被各Follower服务器同步的事务以Proposal消息的形式逐个发送给Follower服务器，并在每一个Proposal消息后面紧接着再发送一个Commit消息，以表示该事务已经被提交。等到Follower服务器将所有其尚未同步的事务Proposal都从Leader服务器上同步过来并成功应用到本地数据库中后，Leader服务器就会将该Follower服务器加入到真正的可用Follower列表并开始之后的其他流程。



- 上面讲到的是正常情况下的数据同步逻辑，下面来看ZAB协议是如何处理那些需要被丢弃的事务Proposal的。在ZAB协议的事务编号ZXID设计中，ZXID是一个64位的数字，其中低32位可以看做是一个简单的单调递增的计数器，针对客户端的每一个事务请求，Leader服务器在产生一个新的事务Proposal时，都会对该计数器进行加1操作；而高32位则代表了Leader周期epoch的编号，每当选举产生一个新的Leader时，就会从这个Leader上取出其本地日志中最大事务Proposal的ZXID，并从该ZXID中解析出对应的epoch值，然后再对其进行加1操作，之后就会以此编号作为新的epoch，并将低32位重置为0来开始生成新的ZXID。ZAB协议这一通过epoch编号来区分Leader周期变化的策略，能够有效地避免不同的Leader服务器错误地使用相同的ZXID编号提出不一样的事务Proposal的异常情况，这对于识别在Leader崩溃恢复前后生成的Proposal非常有帮助，大大简化和提升了数据恢复流程。基于这样的策略，当一个包含了上一个Leader周期中尚未提交过的事务Proposal的服务器启动时，其肯定无法成为Leader，原因很简单，因为当前集群中一定包含了一个Quorum（过半）集合，该集合中的机器一定包含了更高epoch的事务的Proposal，因此这台机器的事务Proposal肯定不是最高，也就无法成为Leader了。当这台机器加入到集群中，以Follower角色连接上Leader服务器之后，Leader服务器会根据自己服务器上最后被提交的Proposal来和Follower服务器的proposal进行对比，对比的结果当然是Leader会要求Follower进行一个回退操作 —— 回退到一个确实已经被集群中过半机器提交的最新的事务Proposal。



#### （三）、ZAB与Paxos算法的联系与区别 ####

**联系：**

- 两者都存在一个类似于Leader进程的角色，由其负责协调多个Follower进程的运行。
- Leader进程都会等待超过半数的Follower做出正确的反馈后，才会将一个提案进行提交。
- 在ZAB协议中，每个Proposal中都包含了一个epoch值，用来代表当前的Leader周期，在Paxos算法中，同样存在这样的一个标识，只是名字变成了Ballot。

**区别：**

- Paxos算法中，新选举产生的主进程会进行两个阶段的工作，第一阶段称为读阶段，新的主进程和其他进程通信来收集主进程提出的提议，并将它们提交。第二阶段称为写阶段，当前主进程开始提出自己的提议；ZAB协议在Paxos基础上添加了同步阶段，此时，新的Leader会确保存在过半的Follower已经提交了之前的Leader周期中的所有事务Proposal。
- ZAB协议主要用于构建一个高可用的分布式数据主备系统，而Paxos算法则用于构建一个分布式的一致性状态机系统。














































































































































































































































































































































































































